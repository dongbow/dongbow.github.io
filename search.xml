<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL - 简单介绍 & 类型]]></title>
    <url>%2F2019%2F08%2F19%2Fmysql-1%2F</url>
    <content type="text"><![CDATA[SQL简介SQL 是Structure Query Language（结构化查询语言）的缩写，它是使用关系模型的数据库应用语言。SQL的扩展语言有MySQL、SQL Service等。 SQL 语句主要可以划分为以下3 个类别： DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括create、drop、alter等。 DML（Data Manipulation Language）语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括insert、delete、udpate 和select 等。 DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke 等。 MySQL在线帮助文档 HELP contents 查看MySQL命令的使用。其中显示所有可供查询的的分类。当需要具体到某个类的时候，可以使用HELP 类别名。eg：HELP &#39;Data Type&#39; 查看所有的数据类型的使用方法。根据全部的一级一级的筛选查询自己想要的内容 可以通过SHOW VARIABLES语句查看系统变量及其值。eg:SHOW VARIABLES like &#39;%show%&#39; 在MySQL中，我们可以使用SHOW STATUS指令语句来查看MySQL服务器的状态信息。当我们希望能够「按需查看」一部分状态信息。这个时候，我们可以在show status语句后加上对应的like子句。例如，我们想要查看当前MySQL启动后的运行时间，我们可以执行如下语句：show status like &#39;%select%&#39; 查看MySQL版本号：select version() MySQL 支持的数据类型整型介绍整型宽度对于整型数据，MySQL还支持在类型名称后面的小括号内指定显示宽度，例如int(5)表示当数值宽度小于5位的时候在数字前面填满宽度，如果不显示指定宽度则默认为int(11)。设置了宽度限制后，如果插入大于宽度限制的值，会不会截断或者插不进去报错？答案是肯定的：不会对插入的数据有任何影响，还是按照类型的实际精度进行保存. UNSIGNED属性所有的整数类型都有一个可选属性UNSIGNED（无符号），如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项，它的取值范围是正常值的下限取0，上限取原值的2倍，例如，tinyint有符号范围是-128～+127，而无符号范围是0～255。。如果一个列指定为zerofill，则MySQL自动为该列添加UNSIGNED属性. AUTO_INCREMENT属性整数类型还有一个属性：AUTO_INCREMENT。在需要产生唯一标识符或顺序值时，可利用此属性，这个属性只用于整数类型。AUTO_INCREMENT 值一般从1 开始，每行增加1。在插入NULL 到一个AUTO_INCREMENT 列时，MySQL 插入一个比该列中当前最大值大1 的值。一个表中最多只能有一个AUTO_INCREMENT列。对于任何想要使用AUTO_INCREMENT 的列，应该定义为NOT NULL，并定义为PRIMARY KEY 或定义为UNIQUE 键 sql_mode使用有些时候在你添加数据的时候，明明会出现数据溢出的问题，却依然能正常的操作，只是数据却不是自己想要的。这个时候可以看一下sql_mode的设置。sql_mode的基本命令命令select @@sql_mode set @@sql_mode=TRADITIONAL。使用方法 小数介绍分类MySQL 分为两种方式：浮点数和定点数。浮点数包括float（单精度）和double（双精度），而定点数则只有decimal一种表示。定点数在MySQL内部以字符串形式存放，比浮点数更精确，适合用来表示货币等精度高的数据。 使用浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该值一共显示M 位数字（整数位+小数位），其中D位位于小数点后面，M 和D 又称为精度和标度。MySQL 保存值时进行四舍五入，因此如果在float(7,4)列内插入999.00009，近似结果是999.0001。值得注意的是，浮点数后面跟“(M,D)”的用法是非标准用法，如果要用于数据库的迁移，则最好不要这么使用。 注意float 和double在不指定精度时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示，而decimal在不指定精度时，默认的整数位为10，默认的小数位为0。 BIT（位）类型介绍对于BIT（位）类型，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从1～64，如果不写则默认为1位。 使用对于位字段，如果直接使用SELECT命令看不到结果，可以用bin()（显示为二进制格式）或者hex()（显示为十六进制格式）函数进行读取 时间类型分类 类型 字节 最小值 最大值 零值表示 DATE 4 1000-01-01 9999-12-31 0000-00-00 DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 TIMESTAMP 4 19700101080001 2038年的某个时刻 00000000000000 TIME 3 -838:59:59 838:59:59 00:00:00 YEAR 1 1901 2155 0000 这些数据类型的主要区别如下： DATE来表示年月。 DATETIME表示年月日时分秒。 TIME 来表示时分秒。 通常使用TIMESTAMP经常插入或者更新日期为当前系统时间。TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串，显示宽度固定为19个字符。如果想要获得数字值，应在TIMESTAMP列添加+0。 YEAR表示年份，它比DATE占用更少的空间。YEAR有2位或4位格式的年。默认是4位格式。在4位格式中，允许的值是1901～2155 和0000。在2位格式中，允许的值是70～69，表示从1970～2069年。MySQL以YYYY 格式显示YEAR值。使用DATETIME和TIMESTAMP可以设置CURRENT_TIME默认值为当前系统时间。在添加当前时间时，使用函数now()。 12insert into t1(id7) values(now());alter table t1 modify `id5` timestamp NULL DEFAULT CURRENT_TIMESTAMP; TIMESTAMP和DATETIEM区别 TIMESTAMP的插入和查询都受当地时区的影响，更能反应出实际的日期。而DATETIME则只能反应出插入时当地的时区，其他时区的人查看数据必然会有误差的。 案例解释：show variables like &#39;time_zone&#39;当时的时区为SYSTEM，即东八区。时区改为东九区，添加数据，两个字段的属性如下‘id5’ timestamp NULL DEFAULT CURRENT_TIMESTAMP,‘id6’ datetime DEFAULT CURRENT_TIMESTAMP此时两个时间是一致的，都是东九区的时间；然后将时区改为原先的东八区，发现id5时间又变成了东八区的时间，而id6还是原先的九区时间。扩展 查看时区命令 12show variables like 'time_zone';select @@time_zone; 时区的值为“SYSTEM”，这个值默认是和主机的时区值一致的，因为我们在中国，这里的“SYSTEM”实际是东八区（+8:00）。 修改时区的命令 1set time_zone='+9:00'; 字符串类型CHAR &amp; VARCHARCHAR 和VARCHAR 很类似，都用来保存MySQL 中较短的字符串。两者的存储数据范围不一样。另外在存数据的时候，CHAR列删除了尾部的空格，而VARCHAR 则保留这些空格。eg: 12CREATE TABLE vc (v VARCHAR(4), c CHAR(4));INSERT INTO vc VALUES ('ab ', 'ab '); 在添加的时候v是ab&nbsp;&nbsp;而c是ab。 查看长度： 1select length(v),length(c) from vc; length(v) length(c) 4 2 函数字符串函数 函数 功能 注意点 CANCAT(S1,S2,…Sn) 连接S1,S2,…Sn 为一个字符串 连接的内容有个字段为空，则整个为空 concat_ws(separator, str1, str2, …) 和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符 select concat_ws(‘-‘,car_manage_no,car_manage_id) from t1 把分隔符指定为null，结果全部变成了null group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] ) 将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 select warehouse_no, warehouse_name, group_concat(concat(plate_city_name,’-‘,valid_time) order by valid_time desc) from fcm_warehouse_city_valid group by warehouse_no INSERT(str,x,y,instr) 将字符串str 从第x 位置开始，y 个字符长的子串替换为字符串instr LOWER(str) 将字符串str 中所有字符变为小写 UPPER(str) 将字符串str 中所有字符变为大写 LEFT(str ,x) 返回字符串str 最左边的x 个字符 如果第二个参数是NULL，那么将不返回任何字符串 RIGHT(str,x) 返回字符串str 最右边的x 个字符 如果第二个参数是NULL，那么将不返回任何字符串 LPAD(str,n ,pad) 用字符串pad 对str 最左边进行填充，直到长度为n 个字符长度 RPAD(str,n,pad) 用字符串pad 对str 最右边进行填充，直到长度为n 个字符长度 LTRIM(str) 去掉字符串str 左侧的空格 RTRIM(str) 去掉字符串str 行尾的空格 REPEAT(str,x) 返回str 重复x 次的结果 REPLACE(str,a,b) 用字符串b 替换字符串str 中所有出现的字符串a STRCMP(s1,s2) 比较字符串s1和s2 ：比较字符串s1 和s2 的ASCII 码值的大小。如果s1 比s2 小，那么返回-1；如果s1 与s2相等，那么返回0；如果s1 比s2 大，那么返回1 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串str x 位置起y 个字符长度的字串 ###### 数值函数 函数 功能 ABS(x) 返回x 的绝对值 CEIL(x) 返回大于x 的最大整数值 FLOOR(x) 返回小于x 的最大整数值 MOD(x，y) 返回x/y 的模 RAND() 返回0 到1 内的随机值 TRUNCATE(x,y) 返回数字x 截断为y 位小数的结果 ROUND(x,y) 返回参数x 的四舍五入的有y 位小数的值 日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期date 的UNIX 时间戳 FROM_UNIXTIME 返回UNIX 时间戳的日期值 WEEK(date) 返回日期date 为一年中的第几周 YEAR(date) 返回日期date 的年份 HOUR(time) 返回time 的小时值 MINUTE(time) 返回time 的分钟值 MONTHNAME(date) 返回date 的月份名 DATE_FORMAT(date,fmt) 返回按字符串fmt 格式化日期date 值 DATE_ADD(date,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值 DATEDIFF(expr,expr2) 返回起始时间expr 和结束时间expr2 之间的天数，eg：select now() current,date_add(now(),INTERVAL 31 day) after31days,date_add(now(),INTERVAL ‘1_2’ year_month) after_oneyear_twomonth; 其他函数DATABASE() 返回当前数据库名VERSION() 返回当前数据库版本USER() 返回当前登录用户名MD5() 返回字符串str 的MD5 值show table status 查看表信息show table status like ‘%表名%’show index from 表名 MySQL 存储引擎常用命令 查看当前的默认存储引擎命令 1show variables like '%storage_engine%' 查看当前MySQL版本支持的引擎 1show engines; 查看某个表的存储引擎 12345678910show create table 表名;/**结果**/CREATE TABLE `t1` ( `id1` int(11) DEFAULT NULL, `id2` tinyint(5) unsigned DEFAULT NULL, `id3` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `id4` datetime DEFAULT CURRENT_TIMESTAMP, `id5` date DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; ENGINE=InnoDB即展示了表的引擎，当然由此可知，在创建的时候也可以使用这个字段指定表使用的引擎。 修改表的引擎 1alter table table_name engine=引擎名 各类引擎介绍 特点 MyISAM InnoDB MEMORY 存储限制 有 64TB 有 事务安全 支持 锁机制 表锁 行锁 表锁 B树索引 支持 支持 支持 哈希索引 支持 全文索引 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 空间使用 低 高 N/A 内存使用 低 高 中等 批量插入的速度 高 低 高 支持外键 支持 合适数据类型char与varchar CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。由于CHAR是固定长度的，所以它的处理速度比VARCHAR快得多，但是其缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。 在MySQL 中，不同的存储引擎对CHAR 和VARCHAR 的使用原则有所不同，这里简单概括如下。  MyISAM 存储引擎：建议使用固定长度的数据列代替可变长度的数据列。 MEMORY 存储引擎：目前都使用固定长度的数据行存储，因此无论使用CHAR 或VARCHAR 列都没有关系。两者都是作为CHAR 类型处理。  InnoDB 存储引擎：建议使用VARCHAR 类型。对于InnoDB数据表，内部的行存储格式，没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR 列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O 是比较好的。TEXT 与BLOB一般在保存少量字符串的时候，我们会选择CHAR 或者VARCHAR；而在保存较大文本时，通常会选择使用TEXT 或者BLOB，二者之间的主要差别是BLOB 能用来保存二进制数据，比如照片；而TEXT 只能保存字符数据，比如一篇文章或者日记 BLOB 和TEXT值会引起一些性能问题，特别是在执行了大量的删除操作时。删除操作会在数据表中留下很大的“空洞”，以后填入这些“空洞”的记录在插入的性能上会有影响。为了提高性能，建议定期使用OPTIMIZE TABLE功能对这类表进行碎片整理，避免因为“空洞”导致性能问题。 12345// 查看表的物理内存大小select DATA_LENGTH from information_schema.tables where table_schema='finance-car-manage' AND table_name='t2';// 清理零碎内存OPTIMIZE TABLE finance-car-manage.t2; 可以使用合成的（Synthetic）索引来提高大文本字段（BLOB 或TEXT）的查询性能。简单来说，合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了。但是，要注意这种技术只能用于精确匹配的查询（散列值对于类似&lt;或&gt;=等范围搜索操作符是没有用处的）。可以使用MD5()函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。请记住数值型散列值可以很高效率地存储。同样，如果散列算法生成的字符串带有尾部空格，就不要把它们存储在CHAR 或VARCHAR 列中，它们会受到尾部空格去除的影响。合成的散列索引对于那些BLOB 或TEXT 数据列特别有用。用散列标识符值查找的速度比搜索BLOB 列本身的速度快很多。eg：1234insert into t values(1,repeat('beijing',2),md5(context));insert into t values(2,repeat('beijing',2),md5(context));insert into t values(3,repeat('beijing 2008',2),md5(context));select * from t; 查看的内容为： id context hash_value 1 beijingbeijing 09746eef633dbbccb7997dfd795cff17 2 beijingbeijing 09746eef633dbbccb7997dfd795cff17 3 beijing 2008beijing 2008 1c0ddb82cca9ed63e1cacbddd3f74082 - 如果要查询context 值为“beijing 2008beijing 2008”的记录，可以通过相应的散列值来 查询： 1select * from t where hash_value=md5(repeat('beijing 2008',2)); 浮点数与定点数 浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入数据的精度超过该列定义的实际精度，则插入值会被四舍五入到实际定义的精度值，然后插入，四舍五入的过程不会报错。在MySQL中float、double（或real）用来表示浮点数。 定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以定点数可以更加精确的保存数据。如果插入数据超过该列定义的实际精度，会报错或者报警。 浮点数丢失精度的其中一个原因是小数二进制十进制转换导致的。 注意：在今后关于浮点数和定点数的应用中，用户要考虑到以下几个原则：  浮点数存在误差问题；  对货币等对精度敏感的数据，应该用定点数表示或存储； 在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较； 要注意浮点数中一些特殊值的处理。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal简单理解]]></title>
    <url>%2F2019%2F08%2F12%2Fthreadlocal%2F</url>
    <content type="text"><![CDATA[多线程不可避免需要处理状态，处理状态有三种方式：共享可变性、隔离可变性和纯粹不可变。使用ThreadLocal属于隔离可变性的一种方法，但是ThreadLocal使用不当又可能导致内存泄漏，下面简单介绍一下ThreadLocal。 本文基于JDK 1.8 介绍 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID). Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the {@code ThreadLocal} instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist). 核心意思是 ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。 总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。 原理从set方法入手 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public void set(T value) &#123; // 获取当前线程 Thread t = Thread.currentThread(); 获取当前线程Map ThreadLocalMap map = getMap(t); // 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去 if (map != null) map.set(this, value); else createMap(t, value);&#125;``` set方法中一个核心对象是ThreadLocalMap，跟着源码看一下是什么 ```javastatic class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ... ignore &#125;``` 根据源码可以看到，ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储，我们的值都是存储到这个Map上的，key是当前ThreadLocal对象。 当Map存在，直接获取线程Thread中获取。 ```javaThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;``` 可以看出，对象的引用实际是在Thread中。 因此总结一下就是，Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象。![图示](./原理.jpeg) ## 内存泄露问题### 为什么会内存泄漏ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。如果当前线程的生命周期很长（比如线程池管理的线程），一直存在，那么其内部的ThreadLocalMap对象也会一直生存下去，这些null key就存在一条强引用链的关系一直存在：Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value，这条强引用链会导致Entry不会回收，Value不能被回收，导致内存泄漏。![图示](./内存泄露.jpeg) ### JDK的优化当我们调用set() get() remove()，方法的时候，会去清理key为null 的Entry。（但是如果一个ThreadLocal在声明以后再也不调用以上三个方法，也是无法被优化清理的） ```javaprivate int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 注意事项防止内存泄露，使用完需要调用ThreadLocal的remove()方法 常用方法 get() 返回当前线程的此线程局部变量的副本中的值 获取当前线程的属性：ThreadLocal.ThreadLocalMap threadLocals （即：一个map） map中获取线程存储的K-V Entry键值对 返回存储的变量 set(T value) 将当前线程的此线程局部变量的副本设置为指定的值 remove() 删除此线程局部变量的当前线程的值 简单代码示例12345678910111213141516171819202122232425public class TheadLocalExampleHolder &#123; private static final ThreadLocal&lt;User&gt; USER_THREAD_LOCAL = new ThreadLocal&lt;&gt;(); @Data static class User &#123; private String userId; private String userName; &#125; public static User get() &#123; return USER_THREAD_LOCAL.get(); &#125; public static void set(User user) &#123; USER_THREAD_LOCAL.set(user); &#125; public static void remove() &#123; if (USER_THREAD_LOCAL.get() != null) &#123; USER_THREAD_LOCAL.remove(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（三）之 List]]></title>
    <url>%2F2019%2F08%2F08%2Fcollection-1-list-1%2F</url>
    <content type="text"><![CDATA[简介List的特点是有序可重复的。底层实现是数组。Guava List的工具类com.google.common.collect.Lists 关系图graph TB List-->AbstractList AbstractList--> ArrayList AbstractList--> Vector AbstractList-->AbstractSequentialList AbstractSequentialList-->LinkedList Vector-->Stack AbstractList public boolean add(E e) abstract public E get(int index) public E set(int index, E element) public void add(int index, E element) public E remove(int index) public int indexOf(Object o) public int lastIndexOf(Object o) public void clear() public boolean addAll(int index, Collection&lt;? extends E&gt; c) public Iterator iterator() public ListIterator listIterator() public ListIterator listIterator(final int index) public List subList(int fromIndex, int toIndex) public boolean equals(Object o) public int hashCode ArrayListArrayList是一个线程数据不安全的数组，但是他的查询速度较快,增删较慢 常用的方法 public ArrayList(int initialCapacity) public ArrayList() 没有初始化大小则创建一个空的数据 public ArrayList(Collection&lt;? extends E&gt; c) public int size() public boolean isEmpty() public boolean contains(Object o) public int indexOf(Object o) 多个object的时候，返回第一个查询到的下标 public int lastIndexOf(Object o)多个object的时候，返回最后一个查询到的下标 public Object clone() public Object[] toArray() public T[] toArray(T[] a) E elementData(int index) public E get(int index) public E set(int index, E element) 替换 public void add(int index, E element)public boolean addAll(Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) public boolean add(E e) public E remove(int index) public boolean remove(Object o) 多个相同的，只删除最先出现的元素public boolean removeAll(Collection&lt;?&gt; c) public void clear() 只删除元素，并不修改集合的容量 public boolean retainAll(Collection&lt;?&gt; c) public List subList(int fromIndex, int toIndex) public void forEach(Consumer&lt;? super E&gt; action) public boolean removeIf(Predicate&lt;? super E&gt; filter) public void replaceAll(UnaryOperator operator) public void sort(Comparator&lt;? super E&gt; c) ArrayList扩容源码1234567891011121314151617181920212223242526272829303132333435// 添加元素public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果没有指定初始化的集合大小，则将会进入扩容方案newCapacity - minCapacity &lt; 0 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; ArrayList 添加元素源码1234567891011121314151617public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! // 这个是保证有顺序的地方 elementData[size++] = e; return true;&#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // 将添加后面的元素进行copy对应的位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 删除也是和添加类似的处理方式，将删除的元素进行重新的处理。而get则是获取数组下标对应的元素。System.arraycopyc参考 AbstractSequentialList public E get(int index) public E set(int index, E element) public E remove(int index) public boolean addAll(int index, Collection&lt;? extends E&gt; c) public Iterator iterator() public abstract ListIterator listIterator(int index) LinkedListLinkedList底层是一个双向链表，它增删快，效率高，但是查询慢，线程不安全 构造参数由于它的底层实现是链表，所以没有容量大小的定义，只有上个节点，当前节点，下个节点，每个节点都有一个上级节点和一个下级节点 public LinkedList() { } public LinkedList(Collection&lt;? extends E&gt; c) {this(); addAll(c); } 常用方法 public E getLast()public E getFirst()如果是空集合则报错 public E element()调用的是getFirstpublic E peek()空集合也不会报错，返回null，获取首位数据public E peekFirst() 空集合不会报错，返回首位元素public E peekLast()空集合不会报错，返回尾部元素 public E removeFirst()public E remove() 调用上面方法public E removeLast()public boolean remove(Object o)public E remove(int index) public void addFirst(E e)public void push(E e)调动addFirstpublic boolean offerFirst(E e)调用addFirstpublic void addLast(E e)public boolean offerLast(E e)调动上面public boolean add(E e)默认是到尾部添加public boolean offer(E e)调用上面的方法public boolean addAll(Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) 上面的addAll调用这个方法public void add(int index, E element) public boolean contains(Object o)public int indexOf(Object o)获取某个元素的下标。contain调用这个方法 public int size() public void clear() public E get(int index) public E set(int index, E element) public int indexOf(Object o) public int lastIndexOf(Object o) public E poll() 返回首元素，并删除首元素public E pop()返回尾部元素，并删除尾部元素调用removeFirstpublic E pollFirst()返回首元素，并删除首元素public E pollLast()返回尾部元素，并删除尾部元素 添加的部分源码解析123456789101112131415161718192021222324252627282930313233// add方法默认的是在尾部进行新增public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;// Node的结构private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 先获取尾部节点元素，判断是否为null，若为null，说明原链表中没有元素，则把 first 和 last 都赋为当前新增节点。若不为null，说明原链表中有元素，则把last赋为当前新增节点，把原节点的prev级节点修改为当前新增节点 12345678910111213141516// 头部添加public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 头部添加类似于尾部添加 1234567891011121314151617181920212223// 头部删除public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; 如果只有一个元素，那么删除之后first和last都是null，当元素数量大于等于2的时候，删除first之后，将first的next元素置为first，并去掉新first的pre内容 123456789101112131415161718192021222324// 尾部删除public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; 尾部删除类似头部删除，主要复杂的是删除中间的位置，源码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 要删除元素的当前节点x，将当前节点x的上级节点的下级节点设为当前节点x的下级节点，将当前节点x的下级节点的上级节点设为当前节点x的上级节点。中间考虑上级节点或下级节点为空的情况，也就是头部删除与尾部删除 查询元素源码挺简单的，没啥可说的~ 。~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;``` ### VectorVector的底层也是通过数组实现的，默认大小也是10。主要特点：查询快，增删慢，线程安全，但是效率低##### 构造函数- public Vector(int initialCapacity, int capacityIncrement)- public Vector(int initialCapacity)- public Vector()##### 扩容源码```javapublic synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125;&#125;private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; vector的线程安全，主要使用的就是synchronized关键字]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（二）之 Set.md]]></title>
    <url>%2F2019%2F08%2F07%2Fcollection-1-set-1%2F</url>
    <content type="text"><![CDATA[简介Set是一个没有重复数据的集合，Guava Set的工具类com.google.common.collect.Sets 关系图graph LR Set-->SortSet Set-->HashSet Set-->AbstractSet HashSet --> LinkedHashSet AbstractSet-->TreeSet AbstractSet-->EnumSet AbstractSet-->HashSet AbstractSet AbstractSet extends AbstractCollection implements Set AbstractSet是所有set实现类的父类。里面是一些set集合常用的基本方法。 boolean equals(Object o) int hashCode() boolean removeAll(Collection&lt;?&gt; c) 父类AbstractCollection boolean contains(Object o) Object[] toArray() T[] toArray(T[] a) boolean remove(Object o) boolean containsAll(Collection&lt;?&gt; c) boolean addAll(Collection&lt;? extends E&gt; c) boolean removeAll(Collection&lt;?&gt; c) boolean retainAll(Collection&lt;?&gt; c) void clear() String toString() HashSet HashSet的底层是HashMap，使用的Node； 他是一个不重复且无顺序的集合，他的优点就是插入、删除、查询时间复杂度在理想情况下达到O(1)HashSet的构造函数使用的皆是HashMap的构造函数，例如： public HashSet() { map = new HashMap&lt;&gt;();} HashSet的map处理是值为key，value为PRESENT private static final Object PRESENT = new Object(); public Iterator iterator() {return map.keySet().iterator(); } public boolean contains(Object o) {return map.containsKey(o); } public boolean add(E e) {return map.put(e, PRESENT)==null; } public boolean remove(Object o) {return map.remove(o)==PRESENT;} 123456789101112131415161718192021/** * @author yinbingyu * @since 2019/08/05 */public class HashSetExample &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set2 = Sets.newHashSet(); set2.add("语文"); set2.add("数学"); set2.add("英语"); set2.add("历史"); set2.add("政治"); set2.add("地理"); set2.add("生物"); set2.add("语文"); set2.add("化学"); System.out.println(JSON.toJSONString(set2)); System.out.println(set2.contains("生物")); &#125;&#125; 输出结果可知他是一个无序不重复的集合：[&quot;政治&quot;,&quot;生物&quot;,&quot;历史&quot;,&quot;数学&quot;,&quot;化学&quot;,&quot;语文&quot;,&quot;英语&quot;,&quot;地理&quot;] HashSet的存储结构是一个链表 HashSet无序是因为HashMap在新增的时候将数组长度-1 和处理后的hash值进行了与操作 12345678final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); ...... HashMap底层实现参考 TreeSet TreeSet的底层是TreeMap，他之所以有序使用的是红黑树。他的特点是有序且唯一。TreeSet的重点是排序，排序方式。排序方式可以在自定义类中实现Comparable接口，或者Comparator。排序参考 常用的方法: public Iterator descendingIterator() {return m.descendingKeySet().iterator();}返回TreeSet的逆序排列的迭代器。因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public NavigableSet descendingSet() {return new TreeSet&lt;&gt;(m.descendingMap());} 功能同上 public int size() public boolean isEmpty() public boolean contains(Object o) public boolean add(E e) public boolean remove(Object o) public void clear() public boolean addAll(Collection&lt;? extends E&gt; c) public NavigableSet subSet(E fromElement, boolean fromInclusive,E toElement, boolean toInclusive) 截取部分集合，两个boolean类型表示是否是包含两端，其中若是toElement不存在则是截取最后一位public SortedSet subSet(E fromElement, E toElement) 调用的是上面的方法，只是默认前闭后开 public NavigableSet headSet(E toElement, boolean inclusive)public NavigableSet tailSet(E fromElement, boolean inclusive) 一个是从头开始截取，一个是从尾截取public SortedSet headSet(E toElement)public SortedSet tailSet(E fromElement)调用的是上面方法，默认前开后闭 public E first()获取首元素public E last()获取最后一个元素 public E lower(E e) 返回Set中小于e的最大元素public E floor(E e) 返回Set中小于/等于e的最大元素public E ceiling(E e)返回Set中大于/等于e的最小元素 public E higher(E e)返回Set中大于e的最小元素 public E pollFirst()获取第一个元素，并将该元素从TreeMap中删除。public E pollLast()获取最后一个元素，并将该元素从TreeMap中删除。 public Object clone() 1234567891011121314151617181920/** * @author yinbingyu * @since 2019/08/05 */public class TreeSetExample &#123; public static void main(String[] args) &#123; TreeSet&lt;String&gt; treeSet = Sets.newTreeSet(); treeSet.add("1语文"); treeSet.add("3英语"); treeSet.add("2数学"); treeSet.add("4政治"); treeSet.add("5历史"); treeSet.add("6地理"); treeSet.add("7生物"); treeSet.add("8化学"); System.out.println(JSON.toJSONString(treeSet)); &#125;&#125; 输出结果：[“1语文”,”2数学”,”3英语”,”4政治”,”5历史”,”6地理”,”7生物”,”8化学”] 通过断点发现TreeSet在存储数据是 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); LinkedHashSet extends HashSet implements Set底层是LinkedHashMap没有特殊的方法。构造函数调用LinkedHashMapLinkedHashSet是一个哈希表和链表的结合，且是一个双向链表。 双向链表是链表的一种，他的每个数据节点都有两个指针分别指向直接后继和直接前驱，所以从双向链表的任意一个节点开始都可以很方便的访问它的前驱节点和后继节点。这是双向链表的优点，那么有优点就有缺点，缺点是每个节点都需要保存当前节点的next和prev两个属性，这样才能保证优点。所以需要更多的内存开销，并且删除和添加也会比较费时间。LinedHashSet的顺序是数据录入的顺序，但是TreeSet的顺序是可以自定义排序的顺序，两者是不同的。 LinkedHashSet的部分源码如下： 12345678910final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; ...... &#125;&#125; 其中Node&lt;K,V&gt; p有两种实现，第一种是HashMap，第二种是LinkedHashMap。LinkedHashSet使用的是第二种，他的方案是总是将新增的元素添加到最后一个位置，并且会记录他的上个元素及其下个元素的信息。 123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); // 将添加的元素添加到最后一位 linkNodeLast(p); return p;&#125;private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; 其他的实现基本是和HashSet是一致的]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（一）之接口]]></title>
    <url>%2F2019%2F08%2F07%2Fcollection-1-interface%2F</url>
    <content type="text"><![CDATA[背景collection是Java中非常重要的一个存在，类似一个容器将多个object放入到这个容器，同时也可以以容器为单位进行数据的处理。ps:写作的jdk版本1.8 接口关系介绍graph LR Iterator-->Collection Iterator--> ... Collection--> Set Collection--> List Collection--> Queue Collection的父类接口是Iterator，但是Iterator的子类并不仅仅是Collection。 Iterator方法介绍 Iterator.hasNext() 是否还有其他的elements Iterator.next() 查询下一个元素，若是没有元素，抛出异常NoSuchElementException Iterator.remove() 移除 Iterator.forEachRemaining 结合代码更加详细的介绍 123456789101112131415161718192021/** * iterator 例子 * * @author yinbingyu * @since 2019/07/31 */public class IteratorExample &#123; public static void main(String[] args) &#123; Iterator iterator = Lists.newArrayList("set", "list", "java", "mq").iterator(); while (iterator.hasNext()) &#123; String obj = (String)iterator.next(); System.out.println(obj); if (Objects.equals(obj, "list")) &#123; // 移除list元素 iterator.remove(); &#125; &#125; &#125;&#125; 输出的结果setlistjavamq Process finished with exit code 0 1.8之后新增一个新的方法forEachRemaining，其中注意ArrayList的此方法不能使用remove方法 12345678910111213141516171819/** * iterator 例子 * * @author yinbingyu * @since 2019/07/31 */public class IteratorExample &#123; public static void main(String[] args) &#123; Iterator iterator = Lists.newArrayList("set", "list", "java", "mq").iterator(); iterator.forEachRemaining(o -&gt; &#123; System.out.println(o);// if (Objects.equals(o, "list")) &#123;// 使用remove则会报错java.lang.IllegalStateException// iterator.remove();// &#125; &#125;); &#125;&#125; 因为ArrayList.remove使用的是lastRet进行判断的，但是ArrayList.forEachRemaining并没有在遍历的时候更新这个字段，而是在所有的遍历结束的时候才会更新 12345678910111213141516171819202122232425262728public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); ...... &#125; @Override@SuppressWarnings("unchecked")public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification();&#125; Collection方法加粗的是since 1.8适用 int size() 数组的大小 boolean isEmpty() 判断数字是否为空 boolean contains(Object o) 数组是否包含某个元素 Iterator iterator() 返回iterator Object[] toArray() 转为数组 boolean add(E e) 是否添加成功 boolean remove(Object o) 移除某个元素 boolean containsAll(Collection&lt;?&gt; c)是否包含全部 boolean addAll(Collection&lt;? extends E&gt; c)全部添加 boolean removeAll(Collection&lt;?&gt; c) 移除所有 removeIf 自定义移除条件 retainAll 移除非集合中的元素 void clear() 清空集合 boolean equals(Object o) 比较是否相等 int hashCode() spliterator() 可分割迭代器 Stream stream() 变成一个流处理 Stream parallelStream() 变成一个平流 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = Lists.newArrayList("d", "a", "b", "c"); List&lt;String&gt; retainList = Lists.newArrayList("b","c"); list.retainAll(retainList); // bc list.forEach(o-&gt; System.out.println(o)); List&lt;String&gt; list2 = Lists.newArrayList("d", "a", "b", "c"); list2.removeIf(o -&gt; o.equals("a")); // dbc list2.forEach(o-&gt; System.out.println(o));&#125; Collection相关工具类 java.util.Collections com.google.common.collect.Collections2 org.springframework.util.CollectionUtils org.springframework.cglib.core.CollectionUtils org.apache.commons.collections.CollectionUtils]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapstruct简介和使用]]></title>
    <url>%2F2019%2F07%2F23%2Fmapstruct%2F</url>
    <content type="text"><![CDATA[简介mapstrct是一个很好注释处理的框架，解决繁琐domain之间值的转换，节约开发的时间，同时相对应copyProperty的好处是没有使用反射技术，使性能更优。mapstrut一共两个主要的包，org.mapstruct.mapstruct包含里面常用的注释，org.mapstruct.mapstruct-processor处理注释的实现。 官方文档文档传送门 API &amp; 使用MAVEN123456789101112131415161718192021222324252627&lt;!-- 指定版本 --&gt;&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;!-- 引入依赖 --&gt;&lt;dependencies&gt; &lt;!--mapstruct主键--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mapstruct插件 可以直接点击查看mapstruct的实现类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;dependency&gt; &lt;!-- mapstruct实现类执行器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;private&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本使用 定义一个接口，并使用@Mapper 定义一个转换的方法。方法上常用的注解 12@Mapping(target="",source="")、@Mappings(&#123;@Mapping(target="",source=""),@Mapping(target="",source="")&#125;) ps:如果target和source字段相同的则无需使用注解，mapstruct会自动为我们copy值的方法名称上面如果有个可以忽略自动引入的注解,可以防止target copy source的时候报错@BeanMapping(ignoreByDefault=true) eg:基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item &#123; Long itemId; String title;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Sku &#123; Long skuId; String code; Integer price;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class SkuDTO &#123; Long skuId; String skuCode; Integer skuPrice; Long itemId; String itemName;&#125;@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); @BeanMapping(ignoreByDefault = true) @Mappings(&#123; @Mapping(source = "sku.code", target = "skuCode"), @Mapping(source = "sku.price", target = "skuPrice"), @Mapping(source = "item.title", target = "itemName") &#125;) SkuDTO domain2Dto(Sku sku, Item item);&#125; mapstruct 自动实现接口代码如下 1234567891011121314151617181920212223242526@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T18:14:08+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO domain2Dto(Sku sku, Item item) &#123; if ( sku == null &amp;&amp; item == null ) &#123; return null; &#125; SkuDTO skuDTO = new SkuDTO(); if ( sku != null ) &#123; skuDTO.setSkuPrice( sku.getPrice() ); skuDTO.setSkuCode( sku.getCode() ); &#125; if ( item != null ) &#123; skuDTO.setItemName( item.getTitle() ); &#125; return skuDTO; &#125;&#125; 因为使用了@BeanMapping(ignoreByDefault = true)，所以可以看到只有我们指定的那些字段才进行了赋值，如果，我们去掉@BeanMapping，他的实现类是这样的 1234567891011121314151617181920212223242526272829@Generated( value = &quot;org.mapstruct.ap.MappingProcessor&quot;, date = &quot;2019-07-30T18:17:19+0800&quot;, comments = &quot;version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)&quot;)public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO domain2Dto(Sku sku, Item item) &#123; if ( sku == null &amp;&amp; item == null ) &#123; return null; &#125; SkuDTO skuDTO = new SkuDTO(); if ( sku != null ) &#123; skuDTO.setSkuPrice( sku.getPrice() ); skuDTO.setSkuCode( sku.getCode() ); skuDTO.setSkuId( sku.getSkuId() ); &#125; if ( item != null ) &#123; skuDTO.setItemName( item.getTitle() ); skuDTO.setItemId( item.getItemId() ); &#125; return skuDTO; &#125;&#125; 类型的转换有三种特殊的 常见基本类型的不同，@Mapping 会自动转换 bean不同的类型的转换 会创建或者调用其他的方法 collection类型，如果相同的类型他会重新创建一个新的实例集合，并且赋值，如果不同的则会分开进行赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item1 &#123; Long itemId; String title;&#125;/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item2 &#123; Long itemId; String title;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Sku2 &#123; Long skuId; String skuCode; String skuPrice; List&lt;String&gt; nameList; Item1 item;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class SkuDTO2 &#123; Long skuId; String skuCode; Long skuPrice; List&lt;String&gt; nameList; Item2 item;&#125;@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); SkuDTO2 domain2Dto(Sku2 sku2);&#125;// 以下为mapstruct自动生成public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO2 domain2Dto(Sku2 sku2) &#123; if ( sku2 == null ) &#123; return null; &#125; SkuDTO2 skuDTO2 = new SkuDTO2(); skuDTO2.setSkuId( sku2.getSkuId() ); skuDTO2.setSkuCode( sku2.getSkuCode() ); if ( sku2.getSkuPrice() != null ) &#123; skuDTO2.setSkuPrice( Long.parseLong( sku2.getSkuPrice() ) ); &#125; List&lt;String&gt; list = sku2.getNameList(); if ( list != null ) &#123; skuDTO2.setNameList( new ArrayList&lt;String&gt;( list ) ); &#125; skuDTO2.setItem( item1ToItem2( sku2.getItem() ) ); return skuDTO2; &#125; protected Item2 item1ToItem2(Item1 item1) &#123; if ( item1 == null ) &#123; return null; &#125; Item2 item2 = new Item2(); item2.setItemId( item1.getItemId() ); item2.setTitle( item1.getTitle() ); return item2;&#125; mapstruct可以自定义类型转换，只要入参的类型和返回值类型需要的一致，就会自动调用。同时mapstruct的定义不仅仅可以使用接口，也可以使用抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author yinbingyu * @since 2019/07/30 */@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); SkuDTO2 domain2Dto(Sku2 sku2); default Item2 item1ToItem2(Item1 item1) &#123; if (item1 == null) &#123; return null; &#125; Item2 item2 = new Item2(); item2.setItemId(11111L); item2.setTitle(item1.getTitle()); return item2; &#125;&#125;// mapstruct 的实现类@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T18:38:11+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO2 domain2Dto(Sku2 sku2) &#123; if ( sku2 == null ) &#123; return null; &#125; SkuDTO2 skuDTO2 = new SkuDTO2(); skuDTO2.setSkuId( sku2.getSkuId() ); skuDTO2.setSkuCode( sku2.getSkuCode() ); if ( sku2.getSkuPrice() != null ) &#123; skuDTO2.setSkuPrice( Long.parseLong( sku2.getSkuPrice() ) ); &#125; List&lt;String&gt; list = sku2.getNameList(); if ( list != null ) &#123; skuDTO2.setNameList( new ArrayList&lt;String&gt;( list ) ); &#125; // mapstruct直接调用的是在接口中自定义的实现 skuDTO2.setItem( item1ToItem2( sku2.getItem() ) ); return skuDTO2; &#125;&#125; mapstruct支持多个参数的，如果名字一样则会自动映射，不同则需要使用@Mapping，如果多个参数的都有target的属性名需要制定是哪个source的属性名，否则会报错 123456789101112131415161718192021222324252627/** * @author yinbingyu * @since 2019/07/01 */@Mapperpublic interface CarAssertApiMapper &#123; CarAssertApiMapper INSTANCE = Mappers.getMapper(CarAssertApiMapper.class); /** * 两个do转成一个dto * * @param purchaseBillItemDO 采购明细单 * @param carManageDO 车型 * @return 目的dto */ @Mappings(&#123; @Mapping(target = "modelCode", source = "carManageDO.modelCode"), @Mapping(target = "modelName", source = "carManageDO.modelName"), @Mapping(target = "modelColor", source = "carManageDO.modelColor"), @Mapping(target = "modelColorCode", source = "carManageDO.modelColorCode"), @Mapping(target = "interiorColor", source = "carManageDO.interiorColor"), @Mapping(target = "interiorColorCode", source = "carManageDO.interiorColorCode"), @Mapping(target = "purchaseBillItemId", source = "purchaseBillItemDO.billItemId") &#125;) PurchaseCreateDTO doToDto(PurchaseBillItemDO purchaseBillItemDO, CarManageDO carManageDO);&#125; mapstruct可以直接将一个基本类型的字段直接映射对应的bean字段 12345678910111213141516171819202122232425/** * @author yinbingyu * @since 2019/05/29 */@Mapperpublic interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 多个参数转换为targetDTO * * @param carDO source car DO * @param warehouseDO source warehouse DO * @param userName 操作人 这个会直接映射到目标bean的相同字段属性上， * 若是属性名不一致，则需要使用@Mapping * @return target DTO * ps:多个mapping可能使用Mappings更方便 * @Mappings(&#123; * @Mapping(source = &quot;warehouseDO.plate_cities&quot;, target = &quot;plateCities&quot;) * &#125;) */ @Mapping(source = &quot;warehouseDO.plate_cities&quot;, target = &quot;plateCities&quot;) CarDTO severalSourceToDTo(CarDO carDO, WarehouseDO warehouseDO, String userName);&#125; mapstruct不仅仅可以create instance, 也可以更新instance，使用@MappingTarget 1234567891011121314151617/** * @author yinbingyu * @since 2019/05/29 */@Mapperpublic interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 更新DTO里的值 * * @param carDTO target update instance * @param inventoryDO source do */ void updateCarDTO(@MappingTarget CarDTO carDTO, InventoryDO inventoryDO);&#125; 如果两个方向入参和返回值是相反，但是类型却是一样的，则可以使用反向映射@InheritInverseConfiguration,如果有多个复合条件的则可以指定固定的一个方法 123456789101112131415161718192021222324252627282930313233343536/** * @author yinbingyu * @since 2019/05/30 */@Mapper(typeConversionPolicy = ReportingPolicy.IGNORE)public abstract class CustomerMapper &#123; public final static CustomerMapper INSTANCE = Mappers.getMapper(CustomerMapper.class); /** * do转成dto * * @param customerDO * @return */ @Mapping(source = "items", target = "memberItems") abstract CustomerDTO customerCovert(CustomerDO customerDO); /** * do 转dto * 作用和上面的转换是相同的 * @param customerDO1 * @return */ @Mapping(source = "items", target = "memberItems") abstract CustomerDTO customerDTO(CustomerDO customerDO1); /** * dto convert do * * @param customerDTO * @return */ @InheritInverseConfiguration(name = "customerCovert") abstract CustomerDO dtoCoverDTO(CustomerDTO customerDTO);&#125; mapstruct的依赖注入方式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author yinbingyu * @since 2019/06/03 */@Mapper(componentModel = "spring")public interface CarCdiMapper &#123; /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ CarDTO doToDTO(CarDO carDO);&#125;/** * @author yinbingyu * @since 2019/05/29 */public class CarMapperTest &#123; @Autowired private CarCdiMapper carCdiMapper; @Test public void testCDI() &#123; CarDO carDO = CarDO.builder() .newCarGuidePrice(15880000L) .brandCode("brand-74") .brandName("JEEP") .seriesCode("series-50225") .seriesName("自由侠") .modelCode("14475-n") .modelName("2017款 自由侠 180T 自动劲能版") .modelColor("皓白") .modelColorCode("#FFFFFF") .build(); CarDTO carDTO = carCdiMapper.doToDTO(carDO); System.out.println(carDTO); &#125;&#125;// 其他的请参考@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Mapper &#123; /** * Specifies the component model to which the generated mapper should * adhere. Supported values are * &lt;ul&gt; * &lt;li&gt; &#123;@code default&#125;: the mapper uses no component model, instances are * typically retrieved via &#123;@link Mappers#getMapper(Class)&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code cdi&#125;: the generated mapper is an application-scoped CDI bean and * can be retrieved via &#123;@code @Inject&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code spring&#125;: the generated mapper is a Spring bean and * can be retrieved via &#123;@code @Autowired&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code jsr330&#125;: the generated mapper is annotated with &#123;@code @javax.inject.Named&#125; and * &#123;@code @Singleton&#125;, and can be retrieved via &#123;@code @Inject&#125;&lt;/li&gt; * &lt;/ul&gt; * The method overrides an unmappedTargetPolicy set in a central configuration set * by &#123;@link #config() &#125; * * @return The component model for the generated mapper. */ String componentModel() default "default";&#125; Data type conversions 可以自动类型转换的常见的类型及其他们的包装类mapstruct都是进行自动类型转换的。同时有些类型是可以转成string类型的。mapstruct也是支持自定义类型的转换的@Mapper(uses = 自定义转换类.class)当然也支持格式化，但是格式化的的参数同java.text.DecimalFormat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** * @author yinbingyu * @since 2019/06/04 */@Mapper(uses = BooleanStrategy.class)public interface InventoryMapper &#123; InventoryMapper INSTANCE = Mappers.getMapper(InventoryMapper.class); /** * DO 转 DTO * * @param inventoryDO * @return */ @Mappings(&#123; @Mapping(target = "actualOutWarehouseDate", dateFormat = "yyyy-MM-dd HH:mm:ss"), @Mapping(target = "totalPrice", numberFormat = "\\u00A4#,###,###.00"), @Mapping(target = "inWaySubStatusEnum", source = "inventoryStatusEnum") &#125;) InventoryDTO doToDto(InventoryDO inventoryDO); /** * dto 转 DO * ignore可以忽略某个字段@BeanMapping可以忽略 所有满足自动转换的字段 * * @param inventoryDTO * @return */ @Mappings(&#123; @Mapping(target = "actualOutWarehouseDate", dateFormat = "yyyy-MM-dd HH:mm:ss"), @Mapping(target = "inventoryStatusEnum", source = "inWaySubStatusEnum"), @Mapping(target = "vin", ignore = true) &#125;) InventoryDO dtoToDo(InventoryDTO inventoryDTO);&#125;/** * 自定义类型转换策略 * * @author yinbingyu * @since 2019/06/04 */public class BooleanStrategy &#123; public String booleanToString(Boolean value) &#123; if (value == null) &#123; return null; &#125; return value ? "是" : "否"; &#125; public Integer booleanToInteger(Boolean value) &#123; if (value == null) &#123; return null; &#125; return value ? 1 : 0; &#125; public Boolean IntegerToBoolean(Integer value) &#123; if (value == null) &#123; return null; &#125; return value == 0 ? false : true; &#125;&#125;// mapstuct自动实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-15T14:03:23+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class InventoryMapperImpl implements InventoryMapper &#123; private final BooleanStrategy booleanStrategy = new BooleanStrategy(); @Override public InventoryDTO doToDto(InventoryDO inventoryDO) &#123; if ( inventoryDO == null ) &#123; return null; &#125; InventoryDTOBuilder inventoryDTO = InventoryDTO.builder(); if ( inventoryDO.getInventoryStatusEnum() != null ) &#123; inventoryDTO.inWaySubStatusEnum( inventoryDO.getInventoryStatusEnum().name() ); &#125; inventoryDTO.vin( inventoryDO.getVin() ); inventoryDTO.inventoryMainStatus( inventoryDO.getInventoryMainStatus() ); inventoryDTO.inventorySubStatus( inventoryDO.getInventorySubStatus() ); inventoryDTO.actualStorageDate( inventoryDO.getActualStorageDate() ); if ( inventoryDO.getActualOutWarehouseDate() != null ) &#123; inventoryDTO.actualOutWarehouseDate( new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).format( inventoryDO.getActualOutWarehouseDate() ) ); &#125; if ( inventoryDO.getTotalPrice() != null ) &#123; inventoryDTO.totalPrice( createDecimalFormat( "\u00A4#,###,###.00" ).format( inventoryDO.getTotalPrice() ) ); &#125; inventoryDTO.canSale( booleanStrategy.booleanToString( inventoryDO.getCanSale() ) ); inventoryDTO.canMove( booleanStrategy.booleanToInteger( inventoryDO.getCanMove() ) ); return inventoryDTO.build(); &#125; @Override public InventoryDO dtoToDo(InventoryDTO inventoryDTO) &#123; if ( inventoryDTO == null ) &#123; return null; &#125; InventoryDOBuilder inventoryDO = InventoryDO.builder(); if ( inventoryDTO.getInWaySubStatusEnum() != null ) &#123; inventoryDO.inventoryStatusEnum( Enum.valueOf( InventoryStatusEnum.class, inventoryDTO.getInWaySubStatusEnum() ) ); &#125; inventoryDO.inventoryMainStatus( inventoryDTO.getInventoryMainStatus() ); inventoryDO.inventorySubStatus( inventoryDTO.getInventorySubStatus() ); inventoryDO.actualStorageDate( inventoryDTO.getActualStorageDate() ); try &#123; if ( inventoryDTO.getActualOutWarehouseDate() != null ) &#123; inventoryDO.actualOutWarehouseDate( new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).parse( inventoryDTO.getActualOutWarehouseDate() ) ); &#125; &#125; catch ( ParseException e ) &#123; throw new RuntimeException( e ); &#125; if ( inventoryDTO.getTotalPrice() != null ) &#123; inventoryDO.totalPrice( new BigDecimal( inventoryDTO.getTotalPrice() ) ); &#125; if ( inventoryDTO.getCanSale() != null ) &#123; inventoryDO.canSale( Boolean.parseBoolean( inventoryDTO.getCanSale() ) ); &#125; inventoryDO.canMove( booleanStrategy.IntegerToBoolean( inventoryDTO.getCanMove() ) ); return inventoryDO.build(); &#125; private DecimalFormat createDecimalFormat( String numberFormat ) &#123; DecimalFormat df = new DecimalFormat( numberFormat ); df.setParseBigDecimal( true ); return df; &#125;&#125; ps:那些需要可能失去精度的转换可以控制他们的方案，是否需要抛异常默认是 ReportingPolicy typeConversionPolicy() default ReportingPolicy.IGNORE; 自定义类型转换 一种是上面说到的@Mapper(uses = BooleanStrategy.class) 另外一种是需要自定义多个相同的映射法则的时候，可以使用@Qualifier注解 默认值的问题defaultValue 必须是target和source必须都有的情况下才可以赋值默认值，只有target没有source的时候，可以使用constant 1234567891011121314@Mapper(uses = StringListMapper.class)public interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target = "stringProperty", source = "stringProp", defaultValue = "undefined") @Mapping(target = "longProperty", source = "longProp", defaultValue = "-1") @Mapping(target = "stringConstant", constant = "Constant Value") @Mapping(target = "integerConstant", constant = "14") @Mapping(target = "longWrapperConstant", constant = "3001") @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014") @Mapping(target = "stringListConstants", constant = "jack-jill-tom") Target sourceToTarget(Source s);&#125; 官网说明 If s.getStringProp() == null, then the target property stringProperty will be set to “undefined” instead of applying the value from s.getStringProp(). If s.getLongProperty() == null, then the target property longProperty will be set to -1. The String “Constant Value” is set as is to the target property stringConstant. The value “3001” is type-converted to the Long (wrapper) class of target property longWrapperConstant. Date properties also require a date format. The constant “jack-jill-tom” demonstrates how the hand-written class StringListMapper is invoked to map the dash-separated list into a List. Mapping Collection 原理是遍历source collection然后转换类型，put到target collection中如果是可以自动转换的则自动转换，同date type conversion；若是无法自动转换的，则会查看是否有可以调用的类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Mapper(imports = Date.class)public interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 基本类型collection的转换 * * @param integers * @return */ Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers); /** * 调用存在已有方法的转换 * * @param cars * @return */ List&lt;CarDTO&gt; carsToCarDtos(List&lt;CarDO&gt; cars); /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ @Mapping(target = "userName", constant = "yby") @Mapping(target = "modelColor", source = "modelColor", defaultValue = "标致") @Mapping(target = "createTime", dateFormat = "yyyy-MM-dd HH:mm:ss", expression = "java(new Date())") CarDTO doToDTO(CarDO carDO);&#125;// mapstruct实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:27:05+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class CarMapperImpl implements CarMapper &#123; @Override public Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers) &#123; if ( integers == null ) &#123; return null; &#125; Set&lt;String&gt; set = new HashSet&lt;String&gt;( Math.max( (int) ( integers.size() / .75f ) + 1, 16 ) ); for ( Integer integer : integers ) &#123; set.add( String.valueOf( integer ) ); &#125; return set; &#125; @Override public List&lt;CarDTO&gt; carsToCarDtos(List&lt;CarDO&gt; cars) &#123; if ( cars == null ) &#123; return null; &#125; List&lt;CarDTO&gt; list = new ArrayList&lt;CarDTO&gt;( cars.size() ); for ( CarDO carDO : cars ) &#123; list.add( doToDTO( carDO ) ); &#125; return list; &#125; @Override public CarDTO doToDTO(CarDO carDO) &#123; if ( carDO == null ) &#123; return null; &#125; CarDTO carDTO = new CarDTO(); if ( carDO.getModelColor() != null ) &#123; carDTO.setModelColor( carDO.getModelColor() ); &#125; else &#123; carDTO.setModelColor( "标致" ); &#125; if ( carDO.getNewCarGuidePrice() != null ) &#123; carDTO.setNewCarGuidePrice( BigDecimal.valueOf( carDO.getNewCarGuidePrice() ) ); &#125; carDTO.setBrandCode( carDO.getBrandCode() ); carDTO.setBrandName( carDO.getBrandName() ); carDTO.setSeriesCode( carDO.getSeriesCode() ); carDTO.setSeriesName( carDO.getSeriesName() ); carDTO.setModelCode( carDO.getModelCode() ); carDTO.setModelName( carDO.getModelName() ); carDTO.setModelColorCode( carDO.getModelColorCode() ); carDTO.setUserName( "yby" ); carDTO.setCreateTime( new Date() ); return carDTO; &#125;&#125; 没有可以调用的方法，则mapstruct尝试自己实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author yinbingyu * @since 2019/07/25 */@Mapperpublic interface WarehouseMapper &#123; WarehouseMapper INSTANCE = Mappers.getMapper(WarehouseMapper.class); /** * DTO转为VO * * @param warehouseValidDTOList * @return */ List&lt;WarehouseValidPageVO&gt; dtoToVo(List&lt;WarehouseValidDTO&gt; warehouseValidDTOList);&#125;// mapstruct 自己实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T15:53:04+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class WarehouseMapperImpl implements WarehouseMapper &#123; @Override public List&lt;WarehouseValidPageVO&gt; dtoToVo(List&lt;WarehouseValidDTO&gt; warehouseValidDTOList) &#123; if ( warehouseValidDTOList == null ) &#123; return null; &#125; List&lt;WarehouseValidPageVO&gt; list = new ArrayList&lt;WarehouseValidPageVO&gt;( warehouseValidDTOList.size() ); for ( WarehouseValidDTO warehouseValidDTO : warehouseValidDTOList ) &#123; list.add( warehouseValidDTOToWarehouseValidPageVO( warehouseValidDTO ) ); &#125; return list; &#125; protected WarehouseValidPageVO warehouseValidDTOToWarehouseValidPageVO(WarehouseValidDTO warehouseValidDTO) &#123; if ( warehouseValidDTO == null ) &#123; return null; &#125; WarehouseValidPageVO warehouseValidPageVO = new WarehouseValidPageVO(); warehouseValidPageVO.setId( warehouseValidDTO.getId() ); warehouseValidPageVO.setWarehouseNo( warehouseValidDTO.getWarehouseNo() ); warehouseValidPageVO.setWarehouseName( warehouseValidDTO.getWarehouseName() ); warehouseValidPageVO.setPlateValid( warehouseValidDTO.getPlateValid() ); return warehouseValidPageVO; &#125;&#125; map 12345678910111213141516171819202122232425262728293031public interface SourceTargetMapper &#123; @MapMapping(valueDateFormat = "dd.MM.yyyy") Map&lt;String, String&gt; longDateMapToStringStringMap(Map&lt;Long, Date&gt; source);&#125;// mapstruct自己实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:35:22+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class SourceTargetMapperImpl implements SourceTargetMapper &#123; @Override public Map&lt;String, String&gt; longDateMapToStringStringMap(Map&lt;Long, Date&gt; source) &#123; if ( source == null ) &#123; return null; &#125; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;( Math.max( (int) ( source.size() / .75f ) + 1, 16 ) ); for ( java.util.Map.Entry&lt;Long, Date&gt; entry : source.entrySet() ) &#123; String key = new DecimalFormat( "" ).format( entry.getKey() ); String value = new SimpleDateFormat( "dd.MM.yyyy" ).format( entry.getValue() ); map.put( key, value ); &#125; return map; &#125;&#125; stream类型转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Mapper(imports = Date.class)public interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ @Mapping(target = "userName", constant = "yby") @Mapping(target = "modelColor", source = "modelColor", defaultValue = "标致") @Mapping(target = "createTime", dateFormat = "yyyy-MM-dd HH:mm:ss", expression = "java(new Date())") CarDTO doToDTO(CarDO carDO); /** * stream的类型转换 * * @param integers * @return */ Set&lt;String&gt; integerStreamToStringSet(Stream&lt;Integer&gt; integers); /** * stream的类型转换 * * @param cars * @return */ List&lt;CarDTO&gt; carsStreamToCarDtos(Stream&lt;CarDO&gt; cars);&#125;// mapstruct 实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:38:25+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class CarMapperImpl implements CarMapper &#123; @Override public Set&lt;String&gt; integerStreamToStringSet(Stream&lt;Integer&gt; integers) &#123; if ( integers == null ) &#123; return null; &#125; return integers.map( integer -&gt; String.valueOf( integer ) ) .collect( Collectors.toCollection( HashSet&lt;String&gt;::new ) ); &#125; @Override public List&lt;CarDTO&gt; carsStreamToCarDtos(Stream&lt;CarDO&gt; cars) &#123; if ( cars == null ) &#123; return null; &#125; return cars.map( carDO -&gt; doToDTO( carDO ) ) .collect( Collectors.toCollection( ArrayList&lt;CarDTO&gt;::new ) ); &#125; @Override public CarDTO doToDTO(CarDO carDO) &#123; ..... &#125;&#125; Expressions 格式 expression = &quot;java( 表达式 )&quot; 123456789@Mapperpublic interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target = &quot;timeAndFormat&quot;, expression = &quot;java( new org.sample.TimeAndFormat( s.getTime(), s.getFormat() ) )&quot;) Target sourceToTarget(Source s);&#125; 其中使用的类名必须要指定到全路径，若是使用比较麻烦，也可以使用imports 123456789101112131415161718@Mapper(imports = &#123;JSON.class, String.class, OptimusConfig.class&#125;)public interface TicketOuterMapper &#123; /** * 个人牌订单保险信息组装 * * @param plateInfoDO 个人牌保险信息 * @param insuranceCreateDTO 创建保险的原始目标信息 * @return */ @Mappings(&#123; @Mapping(target = "insuranceIdentityCardUrlList", expression = "java(JSON.parseArray(plateInfoDO.getBuyerIdPicList(), String.class))"), @Mapping(target = "financingSite", expression = "java(OptimusConfig.getValue(\"org_name\"))") &#125;) InsuranceCreateDTO personInfoDoToDto(@MappingTarget InsuranceCreateDTO insuranceCreateDTO, PersonalPlateInfoDO plateInfoDO);&#125; Default Expressions 12345678910imports java.util.UUID;@Mapper( imports = UUID.class )public interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target="id", source="sourceId", defaultExpression = "java( UUID.randomUUID().toString() )") Target sourceToTarget(Source s);&#125;]]></content>
      <categories>
        <category>mapstruct</category>
      </categories>
      <tags>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Spring AOP的分布式锁简单实现]]></title>
    <url>%2F2019%2F07%2F23%2Fdislock%2F</url>
    <content type="text"><![CDATA[防止数据的并发操作出现数据不一致，保证操作是幂等的，我们可以对对象加锁、方法加锁，例如synchronized、ReentrantLock等，但是上述Jdk提供的锁时基于内存的，在分布式环境下是不适用的，那么在分布式环境下该如何实现锁操作呢？分布式环境下需要保证集群中对同一数据、方法等操作状态，所以需要把状态单独存储，分布式锁的实现常用方式是基于缓存或者ZK，常用分布式缓存包括Redis和memcached,通过在缓存中设置同一个key和过期时间实现集群中拿到的状态是一致的，ZK是分布式锁实现是基于ZK的临时顺序节点，通过判断同一name下节点是否是最小节点确定是否获取到锁。本文不具体介绍如何实现缓存的写入和删除或者ZK的临时顺序节点创建等实现，主要针对怎么利用Spring AOP消除冗余的if…else,try{}catch(){}等代码，至于为什么，举个正常写一下锁调用的和利用AOP实现的简单对比。 正常写法 public String test() { final String lockKey = "lock_key"; if (!DistributedLock.getInstance().lock(lockKey, 10, TimeUnit.SECONDS)) { // 没有获取到锁, 返回 } try { // 获取到锁, 进行业务逻辑 // ... } finally { // 释放锁 DistributedLock.getInstance().unlock(lockKey); } return "ok"; } AOP实现 @Lock(prefix="lock_key") public String test() { return "ok"; } 看上面两个对比，是不是发现下面的写法很简洁，不用重复写相同的代码了，下面们一下具体实现，其实主要是@Lock注解的定义，和利用AOP对注解的拦截 @Lock package com.github.lock.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @author wangdongbo * @since 2019/7/22. */ @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Lock { /** * 锁前缀, 为空时取'classname_method_' */ String prefix() default ""; /** * 方法参数名，支持方法中的入参，支持方法参数是对象时对象属性的字段 * 不支持集合/数组参数 */ String[] parameter() default {}; /** * 锁定时间 */ int lockSeconds() default 10; /** * 是否重试，默认重试 */ boolean retry() default true; /** * 重试次数，默认为1，retry为true时可用 */ int retryCount() default 1; /** * 没拿到锁时等待多久后重试，retry为true时可用 */ int tryLockSeconds() default 10; /** * 提示 */ String desc() default "数据正在操作中，请稍后再试"; } LockResolver.java package com.github.lock.resolver; import com.github.lock.annotation.Lock; import com.github.lock.exception.LockException; import com.github.lock.util.UUIDUtil; import com.github.lock.way.DistributedLock; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.ArrayUtils; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.LocalVariableTableParameterNameDiscoverer; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.List; import java.util.stream.Stream; /** * @author wangdongbo * @since 2019/7/22. */ @Slf4j @Aspect @Order(1) @Component public class LockResolver { private static final String DOT = "."; private static final String DOT_SPLIT = "\\."; @Autowired private DistributedLock distributedLock; private static LocalVariableTableParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer(); @Pointcut("@annotation(com.github.lock.annotation.Lock)") public void lockAspectMethod() { } @Around("lockAspectMethod()") public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = methodSignature.getMethod(); if (method == null) { throw new LockException("method is empty"); } Lock lock = method.getAnnotation(Lock.class); String prefix; if (!StringUtils.isEmpty(lock.prefix())) { prefix = lock.prefix(); } else { prefix = joinPoint.getTarget().getClass().getSimpleName() + "_" + method.getName() + "_"; } String lockKey = prefix + getArgsConcat(method, lock.parameter(), joinPoint.getArgs()); String requestId = UUIDUtil.getID(); try { if (lock.retry()) { int count = lock.retryCount(); for (int i = 0; i &lt; count; i++) { if (distributedLock.tryLock(lockKey, requestId, lock.lockSeconds(), lock.tryLockSeconds())) { return joinPoint.proceed(); } } } else if (distributedLock.lock(lockKey, requestId, lock.lockSeconds())) { return joinPoint.proceed(); } throw new LockException(lock.desc()); } catch (Throwable e) { log.warn("add lock error:{}", e.getMessage(), e); throw new LockException(e.getMessage(), e); } finally { distributedLock.unlock(lockKey, requestId); } } private String getArgsConcat(Method method, String[] parameter, Object[] args) { String[] params = parameterNameDiscoverer.getParameterNames(method); if (ArrayUtils.isEmpty(parameter)) { return ""; } List&lt;Object&gt; list = Lists.newArrayListWithCapacity(parameter.length); Stream.of(parameter).forEach(s -&gt; { if (s.contains(DOT)) { list.add(parseObj(s, params, args)); } else { int idx = ArrayUtils.indexOf(params, s); list.add(args[idx]); } }); return Joiner.on("_").join(list); } private Object parseObj(String parameter, String[] params, Object[] args) { String firstField = parameter.split(DOT_SPLIT)[0]; int idx = ArrayUtils.indexOf(params, firstField); Object value = args[idx]; Class valueClass = value.getClass(); Object[] fields = ArrayUtils.remove(parameter.split(DOT_SPLIT), 0); for (Object field : fields) { try { Field nextField = valueClass.getDeclaredField(String.valueOf(field)); nextField.setAccessible(true); value = nextField.get(value); valueClass = value.getClass(); } catch (NoSuchFieldException | IllegalAccessException e) { log.error(e.getMessage(), e); } } return value; } } 提供一个锁接口，具体可以根据自己的代码实现具体的功能。 DistributedLock.java package com.github.lock.way; /** * @author wangdongbo * @since 2019/7/22. */ public interface DistributedLock { /** * 加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @return 是否加锁成功 */ boolean lock(String lockKey, String requestId, int seconds); /** * 尝试加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @param trySeconds 拿不到锁,等待多久之后再次尝试加锁[秒] * @return 是否加锁成功 */ boolean tryLock(String lockKey, String requestId, int seconds, int trySeconds); /** * 释放锁 * * @param lockKey key * @param requestId 唯一请求ID * @return 是否成功释放锁 */ boolean unlock(String lockKey, String requestId); } 以上代码就是主要逻辑代码，具体代码实现可以参考工程: 传送门]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存简单介绍]]></title>
    <url>%2F2019%2F07%2F19%2Fcachedesc%2F</url>
    <content type="text"><![CDATA[缓存概念缓存穿透缓存穿透是指攻击者不断发起查询缓存和数据库中都没有的数据，导致压力全部落在数据库，导致数据库压力过大。 解决方案： 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。 缓存击穿缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 解决方案 设置热点数据永远不过期。 读数据库时加互斥锁，写入缓存，其他等待线程就可以从缓存读取 缓存雪崩缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。 设置热点数据永远不过期。 内存缓存框架 比较项 ConcurrentHashMap LRUMap Ehcache Guava Cache Caffeine 读写性能 很好，分段锁 一般，全局加锁 好 好，需要做淘汰操作 很好 淘汰算法 无 LRU，一般 支持多种淘汰算法,LRU,LFU,FIFO LRU，一般 W-TinyLFU, 很好 功能丰富程度 功能比较简单 功能比较单一 功能很丰富 功能很丰富，支持刷新和虚引用等 功能和Guava Cache类似 工具大小 jdk自带类，很小 基于LinkedHashMap，较小 很大，最新版本1.4MB 是Guava工具类中的一个小部分，较小 一般，最新版本644KB 是否持久化 否 否 是 否 否 是否支持集群 否 否 是 否 否 对于ConcurrentHashMap来说，比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是jdk自带的类，在各种框架中依然有大量的使用,比如我们可以用来缓存我们反射的Method,Field等等;也可以缓存一些链接，防止其重复建立。在Caffeine中也是使用的ConcurrentHashMap来存储元素。 对于LRUMap来说，如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。 对于Ehcache来说，由于其jar包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代Ehcache。 对于Guava Cache来说，Guava这个jar包在很多Java应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解Caffeine的情况下可以选择Guava Cache。 总结一下:如果不需要淘汰算法则选择ConcurrentHashMap，如果需要淘汰算法和一些丰富的API，这里推荐选择Caffeine。 分布式缓存框架这里选取比较出名的分布式缓存来作为比较，Memcached，Redis. 不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。 比较项 Memcached Redis 数据结构 只支持简单的Key-Value结构 String,Hash, List, Set, Sorted Set 持久化 不支持 支持 容量大小 数据纯内存，数据存储不宜过多 数据全内存，资源成本考量不宜超过100GB 读写性能 很高 很高(RT0.5ms左右) Memcached：其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。 Redis:支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。 总结:如果服务对延迟比较敏感，Map/Set数据也比较多的话，比较适合Redis。]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>redis</tag>
        <tag>memcached</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean 生命周期]]></title>
    <url>%2F2019%2F07%2F19%2Fspringbean%2F</url>
    <content type="text"><![CDATA[如下图]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Velocity]]></title>
    <url>%2F2019%2F07%2F19%2Fvelocity%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下Velocity渲染模板时最基本的代码 引入Velocity Maven信息 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.google.common.base.Charsets;import com.google.common.collect.Maps;import com.github.pdf.tools.exception.VelocityException;import net.sf.cglib.beans.BeanMap;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import org.apache.velocity.app.VelocityEngine;import java.io.StringWriter;import java.util.Collections;import java.util.Map;import java.util.Objects;import java.util.Properties;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class VelocityTemplate extends AbstractTemplate &#123; private static final Map&lt;String, VelocityEngine&gt; ENGINE_MAP = new ConcurrentHashMap&lt;&gt;(16); private static VelocityEngine getEngine(String templatePath) &#123; if (ENGINE_MAP.containsKey(templatePath)) &#123; return ENGINE_MAP.get(templatePath); &#125; Properties properties = new Properties(); properties.setProperty(Velocity.OUTPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.INPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, templatePath); VelocityEngine velocityEngine = new VelocityEngine(properties); ENGINE_MAP.put(templatePath, velocityEngine); return velocityEngine; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; VelocityContext velocityContext = new VelocityContext(Objects.nonNull(data) ? Maps.newHashMap(BeanMap.create(data)) : Collections.emptyMap()); Template template = getEngine(templatePath).getTemplate(templateName, Charsets.UTF_8.toString()); StringWriter writer = new StringWriter(); template.merge(velocityContext, writer); writer.flush(); return writer.toString(); &#125; catch (Exception e) &#123; throw new VelocityException("Velocity exception", e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Freemarker]]></title>
    <url>%2F2019%2F07%2F19%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下FreeMarker渲染模板时最基本的代码 引入FreeMarker Maven信息 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import com.google.common.base.Charsets;import com.github.pdf.tools.exception.FreeMarkerException;import freemarker.cache.FileTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateExceptionHandler;import java.io.File;import java.io.IOException;import java.io.StringWriter;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class FreeMarkerTemplate extends AbstractTemplate &#123; private static Map&lt;String, FileTemplateLoader&gt; FILE_TEMPLATE_LOADER_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Map&lt;String, Configuration&gt; CONFIGURATION_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Configuration getConfiguration(String templatePath) &#123; if (CONFIGURATION_CACHE.get(templatePath) != null) &#123; return CONFIGURATION_CACHE.get(templatePath); &#125; Configuration config = new Configuration(Configuration.VERSION_2_3_25); config.setDefaultEncoding(Charsets.UTF_8.toString()); config.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); config.setLogTemplateExceptions(false); FileTemplateLoader fileTemplateLoader; try &#123; if (FILE_TEMPLATE_LOADER_CACHE.containsKey(templatePath)) &#123; fileTemplateLoader = FILE_TEMPLATE_LOADER_CACHE.get(templatePath); &#125; else &#123; fileTemplateLoader = new FileTemplateLoader(new File(templatePath)); &#125; &#125; catch (IOException e) &#123; throw new FreeMarkerException("fileTemplateLoader init error!", e); &#125; config.setTemplateLoader(fileTemplateLoader); CONFIGURATION_CACHE.put(templatePath, config); return config; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; Template template = getConfiguration(templatePath).getTemplate(templateName); StringWriter writer = new StringWriter(); template.process(data, writer); writer.flush(); return writer.toString(); &#125; catch (Exception ex) &#123; throw new FreeMarkerException("FreeMarkerUtil process fail", ex); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F07%2F19%2Flinux%2F</url>
    <content type="text"><![CDATA[1grep | zgrep]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
