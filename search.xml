<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThreadLocal简单理解]]></title>
    <url>%2F2019%2F08%2F12%2Fthreadlocal%2F</url>
    <content type="text"><![CDATA[多线程不可避免需要处理状态，处理状态有三种方式：共享可变性、隔离可变性和纯粹不可变。使用ThreadLocal属于隔离可变性的一种方法，但是ThreadLocal使用不当又可能导致内存泄漏，下面简单介绍一下ThreadLocal。 本文基于JDK 1.8 介绍 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID). Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the {@code ThreadLocal} instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist). 核心意思是 ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。 总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。 原理从set方法入手 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public void set(T value) &#123; // 获取当前线程 Thread t = Thread.currentThread(); 获取当前线程Map ThreadLocalMap map = getMap(t); // 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去 if (map != null) map.set(this, value); else createMap(t, value);&#125;``` set方法中一个核心对象是ThreadLocalMap，跟着源码看一下是什么 ```javastatic class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ... ignore &#125;``` 根据源码可以看到，ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储，我们的值都是存储到这个Map上的，key是当前ThreadLocal对象。 当Map存在，直接获取线程Thread中获取。 ```javaThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;``` 可以看出，对象的引用实际是在Thread中。 因此总结一下就是，Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象。![图示](./原理.jpeg) ## 内存泄露问题### 为什么会内存泄漏ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。如果当前线程的生命周期很长（比如线程池管理的线程），一直存在，那么其内部的ThreadLocalMap对象也会一直生存下去，这些null key就存在一条强引用链的关系一直存在：Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value，这条强引用链会导致Entry不会回收，Value不能被回收，导致内存泄漏。![图示](./内存泄露.jpeg) ### JDK的优化当我们调用set() get() remove()，方法的时候，会去清理key为null 的Entry。（但是如果一个ThreadLocal在声明以后再也不调用以上三个方法，也是无法被优化清理的） ```javaprivate int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 注意事项防止内存泄露，使用完需要调用ThreadLocal的remove()方法 常用方法 get() 返回当前线程的此线程局部变量的副本中的值 获取当前线程的属性：ThreadLocal.ThreadLocalMap threadLocals （即：一个map） map中获取线程存储的K-V Entry键值对 返回存储的变量 set(T value) 将当前线程的此线程局部变量的副本设置为指定的值 remove() 删除此线程局部变量的当前线程的值 简单代码示例12345678910111213141516171819202122232425public class TheadLocalExampleHolder &#123; private static final ThreadLocal&lt;User&gt; USER_THREAD_LOCAL = new ThreadLocal&lt;&gt;(); @Data static class User &#123; private String userId; private String userName; &#125; public static User get() &#123; return USER_THREAD_LOCAL.get(); &#125; public static void set(User user) &#123; USER_THREAD_LOCAL.set(user); &#125; public static void remove() &#123; if (USER_THREAD_LOCAL.get() != null) &#123; USER_THREAD_LOCAL.remove(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（三）之 List]]></title>
    <url>%2F2019%2F08%2F08%2Fcollection-1-list-1%2F</url>
    <content type="text"><![CDATA[简介List的特点是有序可重复的。底层实现是数组。Guava List的工具类com.google.common.collect.Lists 关系图graph TB List-->AbstractList AbstractList--> ArrayList AbstractList--> Vector AbstractList-->AbstractSequentialList AbstractSequentialList-->LinkedList Vector-->Stack AbstractList public boolean add(E e) abstract public E get(int index) public E set(int index, E element) public void add(int index, E element) public E remove(int index) public int indexOf(Object o) public int lastIndexOf(Object o) public void clear() public boolean addAll(int index, Collection&lt;? extends E&gt; c) public Iterator iterator() public ListIterator listIterator() public ListIterator listIterator(final int index) public List subList(int fromIndex, int toIndex) public boolean equals(Object o) public int hashCode ArrayListArrayList是一个线程数据不安全的数组，但是他的查询速度较快,增删较慢 常用的方法 public ArrayList(int initialCapacity) public ArrayList() 没有初始化大小则创建一个空的数据 public ArrayList(Collection&lt;? extends E&gt; c) public int size() public boolean isEmpty() public boolean contains(Object o) public int indexOf(Object o) 多个object的时候，返回第一个查询到的下标 public int lastIndexOf(Object o)多个object的时候，返回最后一个查询到的下标 public Object clone() public Object[] toArray() public T[] toArray(T[] a) E elementData(int index) public E get(int index) public E set(int index, E element) 替换 public void add(int index, E element)public boolean addAll(Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) public boolean add(E e) public E remove(int index) public boolean remove(Object o) 多个相同的，只删除最先出现的元素public boolean removeAll(Collection&lt;?&gt; c) public void clear() 只删除元素，并不修改集合的容量 public boolean retainAll(Collection&lt;?&gt; c) public List subList(int fromIndex, int toIndex) public void forEach(Consumer&lt;? super E&gt; action) public boolean removeIf(Predicate&lt;? super E&gt; filter) public void replaceAll(UnaryOperator operator) public void sort(Comparator&lt;? super E&gt; c) ArrayList扩容源码1234567891011121314151617181920212223242526272829303132333435// 添加元素public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果没有指定初始化的集合大小，则将会进入扩容方案newCapacity - minCapacity &lt; 0 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; ArrayList 添加元素源码1234567891011121314151617public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! // 这个是保证有顺序的地方 elementData[size++] = e; return true;&#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // 将添加后面的元素进行copy对应的位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 删除也是和添加类似的处理方式，将删除的元素进行重新的处理。而get则是获取数组下标对应的元素。System.arraycopyc参考 AbstractSequentialList public E get(int index) public E set(int index, E element) public E remove(int index) public boolean addAll(int index, Collection&lt;? extends E&gt; c) public Iterator iterator() public abstract ListIterator listIterator(int index) LinkedListLinkedList底层是一个双向链表，它增删快，效率高，但是查询慢，线程不安全 构造参数由于它的底层实现是链表，所以没有容量大小的定义，只有上个节点，当前节点，下个节点，每个节点都有一个上级节点和一个下级节点 public LinkedList() { } public LinkedList(Collection&lt;? extends E&gt; c) {this(); addAll(c); } 常用方法 public E getLast()public E getFirst()如果是空集合则报错 public E element()调用的是getFirstpublic E peek()空集合也不会报错，返回null，获取首位数据public E peekFirst() 空集合不会报错，返回首位元素public E peekLast()空集合不会报错，返回尾部元素 public E removeFirst()public E remove() 调用上面方法public E removeLast()public boolean remove(Object o)public E remove(int index) public void addFirst(E e)public void push(E e)调动addFirstpublic boolean offerFirst(E e)调用addFirstpublic void addLast(E e)public boolean offerLast(E e)调动上面public boolean add(E e)默认是到尾部添加public boolean offer(E e)调用上面的方法public boolean addAll(Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) 上面的addAll调用这个方法public void add(int index, E element) public boolean contains(Object o)public int indexOf(Object o)获取某个元素的下标。contain调用这个方法 public int size() public void clear() public E get(int index) public E set(int index, E element) public int indexOf(Object o) public int lastIndexOf(Object o) public E poll() 返回首元素，并删除首元素public E pop()返回尾部元素，并删除尾部元素调用removeFirstpublic E pollFirst()返回首元素，并删除首元素public E pollLast()返回尾部元素，并删除尾部元素 添加的部分源码解析123456789101112131415161718192021222324252627282930313233// add方法默认的是在尾部进行新增public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;// Node的结构private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 先获取尾部节点元素，判断是否为null，若为null，说明原链表中没有元素，则把 first 和 last 都赋为当前新增节点。若不为null，说明原链表中有元素，则把last赋为当前新增节点，把原节点的prev级节点修改为当前新增节点 12345678910111213141516// 头部添加public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 头部添加类似于尾部添加 1234567891011121314151617181920212223// 头部删除public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; 如果只有一个元素，那么删除之后first和last都是null，当元素数量大于等于2的时候，删除first之后，将first的next元素置为first，并去掉新first的pre内容 123456789101112131415161718192021222324// 尾部删除public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; 尾部删除类似头部删除，主要复杂的是删除中间的位置，源码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 要删除元素的当前节点x，将当前节点x的上级节点的下级节点设为当前节点x的下级节点，将当前节点x的下级节点的上级节点设为当前节点x的上级节点。中间考虑上级节点或下级节点为空的情况，也就是头部删除与尾部删除 查询元素源码挺简单的，没啥可说的~ 。~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;``` ### VectorVector的底层也是通过数组实现的，默认大小也是10。主要特点：查询快，增删慢，线程安全，但是效率低##### 构造函数- public Vector(int initialCapacity, int capacityIncrement)- public Vector(int initialCapacity)- public Vector()##### 扩容源码```javapublic synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125;&#125;private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; vector的线程安全，主要使用的就是synchronized关键字]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（二）之 Set.md]]></title>
    <url>%2F2019%2F08%2F07%2Fcollection-1-set-1%2F</url>
    <content type="text"><![CDATA[简介Set是一个没有重复数据的集合，Guava Set的工具类com.google.common.collect.Sets 关系图graph LR Set-->SortSet Set-->HashSet Set-->AbstractSet HashSet --> LinkedHashSet AbstractSet-->TreeSet AbstractSet-->EnumSet AbstractSet-->HashSet AbstractSet AbstractSet extends AbstractCollection implements Set AbstractSet是所有set实现类的父类。里面是一些set集合常用的基本方法。 boolean equals(Object o) int hashCode() boolean removeAll(Collection&lt;?&gt; c) 父类AbstractCollection boolean contains(Object o) Object[] toArray() T[] toArray(T[] a) boolean remove(Object o) boolean containsAll(Collection&lt;?&gt; c) boolean addAll(Collection&lt;? extends E&gt; c) boolean removeAll(Collection&lt;?&gt; c) boolean retainAll(Collection&lt;?&gt; c) void clear() String toString() HashSet HashSet的底层是HashMap，使用的Node； 他是一个不重复且无顺序的集合，他的优点就是插入、删除、查询时间复杂度在理想情况下达到O(1)HashSet的构造函数使用的皆是HashMap的构造函数，例如： public HashSet() { map = new HashMap&lt;&gt;();} HashSet的map处理是值为key，value为PRESENT private static final Object PRESENT = new Object(); public Iterator iterator() {return map.keySet().iterator(); } public boolean contains(Object o) {return map.containsKey(o); } public boolean add(E e) {return map.put(e, PRESENT)==null; } public boolean remove(Object o) {return map.remove(o)==PRESENT;} 123456789101112131415161718192021/** * @author yinbingyu * @since 2019/08/05 */public class HashSetExample &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set2 = Sets.newHashSet(); set2.add("语文"); set2.add("数学"); set2.add("英语"); set2.add("历史"); set2.add("政治"); set2.add("地理"); set2.add("生物"); set2.add("语文"); set2.add("化学"); System.out.println(JSON.toJSONString(set2)); System.out.println(set2.contains("生物")); &#125;&#125; 输出结果可知他是一个无序不重复的集合：[&quot;政治&quot;,&quot;生物&quot;,&quot;历史&quot;,&quot;数学&quot;,&quot;化学&quot;,&quot;语文&quot;,&quot;英语&quot;,&quot;地理&quot;] HashSet的存储结构是一个链表 HashSet无序是因为HashMap在新增的时候将数组长度-1 和处理后的hash值进行了与操作 12345678final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); ...... HashMap底层实现参考 TreeSet TreeSet的底层是TreeMap，他之所以有序使用的是红黑树。他的特点是有序且唯一。TreeSet的重点是排序，排序方式。排序方式可以在自定义类中实现Comparable接口，或者Comparator。排序参考 常用的方法: public Iterator descendingIterator() {return m.descendingKeySet().iterator();}返回TreeSet的逆序排列的迭代器。因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public NavigableSet descendingSet() {return new TreeSet&lt;&gt;(m.descendingMap());} 功能同上 public int size() public boolean isEmpty() public boolean contains(Object o) public boolean add(E e) public boolean remove(Object o) public void clear() public boolean addAll(Collection&lt;? extends E&gt; c) public NavigableSet subSet(E fromElement, boolean fromInclusive,E toElement, boolean toInclusive) 截取部分集合，两个boolean类型表示是否是包含两端，其中若是toElement不存在则是截取最后一位public SortedSet subSet(E fromElement, E toElement) 调用的是上面的方法，只是默认前闭后开 public NavigableSet headSet(E toElement, boolean inclusive)public NavigableSet tailSet(E fromElement, boolean inclusive) 一个是从头开始截取，一个是从尾截取public SortedSet headSet(E toElement)public SortedSet tailSet(E fromElement)调用的是上面方法，默认前开后闭 public E first()获取首元素public E last()获取最后一个元素 public E lower(E e) 返回Set中小于e的最大元素public E floor(E e) 返回Set中小于/等于e的最大元素public E ceiling(E e)返回Set中大于/等于e的最小元素 public E higher(E e)返回Set中大于e的最小元素 public E pollFirst()获取第一个元素，并将该元素从TreeMap中删除。public E pollLast()获取最后一个元素，并将该元素从TreeMap中删除。 public Object clone() 1234567891011121314151617181920/** * @author yinbingyu * @since 2019/08/05 */public class TreeSetExample &#123; public static void main(String[] args) &#123; TreeSet&lt;String&gt; treeSet = Sets.newTreeSet(); treeSet.add("1语文"); treeSet.add("3英语"); treeSet.add("2数学"); treeSet.add("4政治"); treeSet.add("5历史"); treeSet.add("6地理"); treeSet.add("7生物"); treeSet.add("8化学"); System.out.println(JSON.toJSONString(treeSet)); &#125;&#125; 输出结果：[“1语文”,”2数学”,”3英语”,”4政治”,”5历史”,”6地理”,”7生物”,”8化学”] 通过断点发现TreeSet在存储数据是 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); LinkedHashSet extends HashSet implements Set底层是LinkedHashMap没有特殊的方法。构造函数调用LinkedHashMapLinkedHashSet是一个哈希表和链表的结合，且是一个双向链表。 双向链表是链表的一种，他的每个数据节点都有两个指针分别指向直接后继和直接前驱，所以从双向链表的任意一个节点开始都可以很方便的访问它的前驱节点和后继节点。这是双向链表的优点，那么有优点就有缺点，缺点是每个节点都需要保存当前节点的next和prev两个属性，这样才能保证优点。所以需要更多的内存开销，并且删除和添加也会比较费时间。LinedHashSet的顺序是数据录入的顺序，但是TreeSet的顺序是可以自定义排序的顺序，两者是不同的。 LinkedHashSet的部分源码如下： 12345678910final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; ...... &#125;&#125; 其中Node&lt;K,V&gt; p有两种实现，第一种是HashMap，第二种是LinkedHashMap。LinkedHashSet使用的是第二种，他的方案是总是将新增的元素添加到最后一个位置，并且会记录他的上个元素及其下个元素的信息。 123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); // 将添加的元素添加到最后一位 linkNodeLast(p); return p;&#125;private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; 其他的实现基本是和HashSet是一致的]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection（一）之接口]]></title>
    <url>%2F2019%2F08%2F07%2Fcollection-1-interface%2F</url>
    <content type="text"><![CDATA[背景collection是Java中非常重要的一个存在，类似一个容器将多个object放入到这个容器，同时也可以以容器为单位进行数据的处理。ps:写作的jdk版本1.8 接口关系介绍graph LR Iterator-->Collection Iterator--> ... Collection--> Set Collection--> List Collection--> Queue Collection的父类接口是Iterator，但是Iterator的子类并不仅仅是Collection。 Iterator方法介绍 Iterator.hasNext() 是否还有其他的elements Iterator.next() 查询下一个元素，若是没有元素，抛出异常NoSuchElementException Iterator.remove() 移除 Iterator.forEachRemaining 结合代码更加详细的介绍 123456789101112131415161718192021/** * iterator 例子 * * @author yinbingyu * @since 2019/07/31 */public class IteratorExample &#123; public static void main(String[] args) &#123; Iterator iterator = Lists.newArrayList("set", "list", "java", "mq").iterator(); while (iterator.hasNext()) &#123; String obj = (String)iterator.next(); System.out.println(obj); if (Objects.equals(obj, "list")) &#123; // 移除list元素 iterator.remove(); &#125; &#125; &#125;&#125; 输出的结果setlistjavamq Process finished with exit code 0 1.8之后新增一个新的方法forEachRemaining，其中注意ArrayList的此方法不能使用remove方法 12345678910111213141516171819/** * iterator 例子 * * @author yinbingyu * @since 2019/07/31 */public class IteratorExample &#123; public static void main(String[] args) &#123; Iterator iterator = Lists.newArrayList("set", "list", "java", "mq").iterator(); iterator.forEachRemaining(o -&gt; &#123; System.out.println(o);// if (Objects.equals(o, "list")) &#123;// 使用remove则会报错java.lang.IllegalStateException// iterator.remove();// &#125; &#125;); &#125;&#125; 因为ArrayList.remove使用的是lastRet进行判断的，但是ArrayList.forEachRemaining并没有在遍历的时候更新这个字段，而是在所有的遍历结束的时候才会更新 12345678910111213141516171819202122232425262728public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); ...... &#125; @Override@SuppressWarnings("unchecked")public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification();&#125; Collection方法加粗的是since 1.8适用 int size() 数组的大小 boolean isEmpty() 判断数字是否为空 boolean contains(Object o) 数组是否包含某个元素 Iterator iterator() 返回iterator Object[] toArray() 转为数组 boolean add(E e) 是否添加成功 boolean remove(Object o) 移除某个元素 boolean containsAll(Collection&lt;?&gt; c)是否包含全部 boolean addAll(Collection&lt;? extends E&gt; c)全部添加 boolean removeAll(Collection&lt;?&gt; c) 移除所有 removeIf 自定义移除条件 retainAll 移除非集合中的元素 void clear() 清空集合 boolean equals(Object o) 比较是否相等 int hashCode() spliterator() 可分割迭代器 Stream stream() 变成一个流处理 Stream parallelStream() 变成一个平流 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = Lists.newArrayList("d", "a", "b", "c"); List&lt;String&gt; retainList = Lists.newArrayList("b","c"); list.retainAll(retainList); // bc list.forEach(o-&gt; System.out.println(o)); List&lt;String&gt; list2 = Lists.newArrayList("d", "a", "b", "c"); list2.removeIf(o -&gt; o.equals("a")); // dbc list2.forEach(o-&gt; System.out.println(o));&#125; Collection相关工具类 java.util.Collections com.google.common.collect.Collections2 org.springframework.util.CollectionUtils org.springframework.cglib.core.CollectionUtils org.apache.commons.collections.CollectionUtils]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapstruct简介和使用]]></title>
    <url>%2F2019%2F07%2F23%2Fmapstruct%2F</url>
    <content type="text"><![CDATA[简介mapstrct是一个很好注释处理的框架，解决繁琐domain之间值的转换，节约开发的时间，同时相对应copyProperty的好处是没有使用反射技术，使性能更优。mapstrut一共两个主要的包，org.mapstruct.mapstruct包含里面常用的注释，org.mapstruct.mapstruct-processor处理注释的实现。 官方文档文档传送门 API &amp; 使用MAVEN123456789101112131415161718192021222324252627&lt;!-- 指定版本 --&gt;&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;!-- 引入依赖 --&gt;&lt;dependencies&gt; &lt;!--mapstruct主键--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mapstruct插件 可以直接点击查看mapstruct的实现类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;dependency&gt; &lt;!-- mapstruct实现类执行器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;private&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本使用 定义一个接口，并使用@Mapper 定义一个转换的方法。方法上常用的注解 12@Mapping(target="",source="")、@Mappings(&#123;@Mapping(target="",source=""),@Mapping(target="",source="")&#125;) ps:如果target和source字段相同的则无需使用注解，mapstruct会自动为我们copy值的方法名称上面如果有个可以忽略自动引入的注解,可以防止target copy source的时候报错@BeanMapping(ignoreByDefault=true) eg:基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item &#123; Long itemId; String title;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Sku &#123; Long skuId; String code; Integer price;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class SkuDTO &#123; Long skuId; String skuCode; Integer skuPrice; Long itemId; String itemName;&#125;@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); @BeanMapping(ignoreByDefault = true) @Mappings(&#123; @Mapping(source = "sku.code", target = "skuCode"), @Mapping(source = "sku.price", target = "skuPrice"), @Mapping(source = "item.title", target = "itemName") &#125;) SkuDTO domain2Dto(Sku sku, Item item);&#125; mapstruct 自动实现接口代码如下 1234567891011121314151617181920212223242526@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T18:14:08+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO domain2Dto(Sku sku, Item item) &#123; if ( sku == null &amp;&amp; item == null ) &#123; return null; &#125; SkuDTO skuDTO = new SkuDTO(); if ( sku != null ) &#123; skuDTO.setSkuPrice( sku.getPrice() ); skuDTO.setSkuCode( sku.getCode() ); &#125; if ( item != null ) &#123; skuDTO.setItemName( item.getTitle() ); &#125; return skuDTO; &#125;&#125; 因为使用了@BeanMapping(ignoreByDefault = true)，所以可以看到只有我们指定的那些字段才进行了赋值，如果，我们去掉@BeanMapping，他的实现类是这样的 1234567891011121314151617181920212223242526272829@Generated( value = &quot;org.mapstruct.ap.MappingProcessor&quot;, date = &quot;2019-07-30T18:17:19+0800&quot;, comments = &quot;version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)&quot;)public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO domain2Dto(Sku sku, Item item) &#123; if ( sku == null &amp;&amp; item == null ) &#123; return null; &#125; SkuDTO skuDTO = new SkuDTO(); if ( sku != null ) &#123; skuDTO.setSkuPrice( sku.getPrice() ); skuDTO.setSkuCode( sku.getCode() ); skuDTO.setSkuId( sku.getSkuId() ); &#125; if ( item != null ) &#123; skuDTO.setItemName( item.getTitle() ); skuDTO.setItemId( item.getItemId() ); &#125; return skuDTO; &#125;&#125; 类型的转换有三种特殊的 常见基本类型的不同，@Mapping 会自动转换 bean不同的类型的转换 会创建或者调用其他的方法 collection类型，如果相同的类型他会重新创建一个新的实例集合，并且赋值，如果不同的则会分开进行赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item1 &#123; Long itemId; String title;&#125;/** * @author yinbingyu * @since 2019/07/30 */@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Item2 &#123; Long itemId; String title;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class Sku2 &#123; Long skuId; String skuCode; String skuPrice; List&lt;String&gt; nameList; Item1 item;&#125;@Data@NoArgsConstructor@FieldDefaults(level = AccessLevel.PRIVATE)@AllArgsConstructorpublic class SkuDTO2 &#123; Long skuId; String skuCode; Long skuPrice; List&lt;String&gt; nameList; Item2 item;&#125;@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); SkuDTO2 domain2Dto(Sku2 sku2);&#125;// 以下为mapstruct自动生成public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO2 domain2Dto(Sku2 sku2) &#123; if ( sku2 == null ) &#123; return null; &#125; SkuDTO2 skuDTO2 = new SkuDTO2(); skuDTO2.setSkuId( sku2.getSkuId() ); skuDTO2.setSkuCode( sku2.getSkuCode() ); if ( sku2.getSkuPrice() != null ) &#123; skuDTO2.setSkuPrice( Long.parseLong( sku2.getSkuPrice() ) ); &#125; List&lt;String&gt; list = sku2.getNameList(); if ( list != null ) &#123; skuDTO2.setNameList( new ArrayList&lt;String&gt;( list ) ); &#125; skuDTO2.setItem( item1ToItem2( sku2.getItem() ) ); return skuDTO2; &#125; protected Item2 item1ToItem2(Item1 item1) &#123; if ( item1 == null ) &#123; return null; &#125; Item2 item2 = new Item2(); item2.setItemId( item1.getItemId() ); item2.setTitle( item1.getTitle() ); return item2;&#125; mapstruct可以自定义类型转换，只要入参的类型和返回值类型需要的一致，就会自动调用。同时mapstruct的定义不仅仅可以使用接口，也可以使用抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author yinbingyu * @since 2019/07/30 */@Mapperpublic interface ItemConvert &#123; ItemConvert INSTANCE = Mappers.getMapper(ItemConvert.class); SkuDTO2 domain2Dto(Sku2 sku2); default Item2 item1ToItem2(Item1 item1) &#123; if (item1 == null) &#123; return null; &#125; Item2 item2 = new Item2(); item2.setItemId(11111L); item2.setTitle(item1.getTitle()); return item2; &#125;&#125;// mapstruct 的实现类@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T18:38:11+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class ItemConvertImpl implements ItemConvert &#123; @Override public SkuDTO2 domain2Dto(Sku2 sku2) &#123; if ( sku2 == null ) &#123; return null; &#125; SkuDTO2 skuDTO2 = new SkuDTO2(); skuDTO2.setSkuId( sku2.getSkuId() ); skuDTO2.setSkuCode( sku2.getSkuCode() ); if ( sku2.getSkuPrice() != null ) &#123; skuDTO2.setSkuPrice( Long.parseLong( sku2.getSkuPrice() ) ); &#125; List&lt;String&gt; list = sku2.getNameList(); if ( list != null ) &#123; skuDTO2.setNameList( new ArrayList&lt;String&gt;( list ) ); &#125; // mapstruct直接调用的是在接口中自定义的实现 skuDTO2.setItem( item1ToItem2( sku2.getItem() ) ); return skuDTO2; &#125;&#125; mapstruct支持多个参数的，如果名字一样则会自动映射，不同则需要使用@Mapping，如果多个参数的都有target的属性名需要制定是哪个source的属性名，否则会报错 123456789101112131415161718192021222324252627/** * @author yinbingyu * @since 2019/07/01 */@Mapperpublic interface CarAssertApiMapper &#123; CarAssertApiMapper INSTANCE = Mappers.getMapper(CarAssertApiMapper.class); /** * 两个do转成一个dto * * @param purchaseBillItemDO 采购明细单 * @param carManageDO 车型 * @return 目的dto */ @Mappings(&#123; @Mapping(target = "modelCode", source = "carManageDO.modelCode"), @Mapping(target = "modelName", source = "carManageDO.modelName"), @Mapping(target = "modelColor", source = "carManageDO.modelColor"), @Mapping(target = "modelColorCode", source = "carManageDO.modelColorCode"), @Mapping(target = "interiorColor", source = "carManageDO.interiorColor"), @Mapping(target = "interiorColorCode", source = "carManageDO.interiorColorCode"), @Mapping(target = "purchaseBillItemId", source = "purchaseBillItemDO.billItemId") &#125;) PurchaseCreateDTO doToDto(PurchaseBillItemDO purchaseBillItemDO, CarManageDO carManageDO);&#125; mapstruct可以直接将一个基本类型的字段直接映射对应的bean字段 12345678910111213141516171819202122232425/** * @author yinbingyu * @since 2019/05/29 */@Mapperpublic interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 多个参数转换为targetDTO * * @param carDO source car DO * @param warehouseDO source warehouse DO * @param userName 操作人 这个会直接映射到目标bean的相同字段属性上， * 若是属性名不一致，则需要使用@Mapping * @return target DTO * ps:多个mapping可能使用Mappings更方便 * @Mappings(&#123; * @Mapping(source = &quot;warehouseDO.plate_cities&quot;, target = &quot;plateCities&quot;) * &#125;) */ @Mapping(source = &quot;warehouseDO.plate_cities&quot;, target = &quot;plateCities&quot;) CarDTO severalSourceToDTo(CarDO carDO, WarehouseDO warehouseDO, String userName);&#125; mapstruct不仅仅可以create instance, 也可以更新instance，使用@MappingTarget 1234567891011121314151617/** * @author yinbingyu * @since 2019/05/29 */@Mapperpublic interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 更新DTO里的值 * * @param carDTO target update instance * @param inventoryDO source do */ void updateCarDTO(@MappingTarget CarDTO carDTO, InventoryDO inventoryDO);&#125; 如果两个方向入参和返回值是相反，但是类型却是一样的，则可以使用反向映射@InheritInverseConfiguration,如果有多个复合条件的则可以指定固定的一个方法 123456789101112131415161718192021222324252627282930313233343536/** * @author yinbingyu * @since 2019/05/30 */@Mapper(typeConversionPolicy = ReportingPolicy.IGNORE)public abstract class CustomerMapper &#123; public final static CustomerMapper INSTANCE = Mappers.getMapper(CustomerMapper.class); /** * do转成dto * * @param customerDO * @return */ @Mapping(source = "items", target = "memberItems") abstract CustomerDTO customerCovert(CustomerDO customerDO); /** * do 转dto * 作用和上面的转换是相同的 * @param customerDO1 * @return */ @Mapping(source = "items", target = "memberItems") abstract CustomerDTO customerDTO(CustomerDO customerDO1); /** * dto convert do * * @param customerDTO * @return */ @InheritInverseConfiguration(name = "customerCovert") abstract CustomerDO dtoCoverDTO(CustomerDTO customerDTO);&#125; mapstruct的依赖注入方式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author yinbingyu * @since 2019/06/03 */@Mapper(componentModel = "spring")public interface CarCdiMapper &#123; /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ CarDTO doToDTO(CarDO carDO);&#125;/** * @author yinbingyu * @since 2019/05/29 */public class CarMapperTest &#123; @Autowired private CarCdiMapper carCdiMapper; @Test public void testCDI() &#123; CarDO carDO = CarDO.builder() .newCarGuidePrice(15880000L) .brandCode("brand-74") .brandName("JEEP") .seriesCode("series-50225") .seriesName("自由侠") .modelCode("14475-n") .modelName("2017款 自由侠 180T 自动劲能版") .modelColor("皓白") .modelColorCode("#FFFFFF") .build(); CarDTO carDTO = carCdiMapper.doToDTO(carDO); System.out.println(carDTO); &#125;&#125;// 其他的请参考@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Mapper &#123; /** * Specifies the component model to which the generated mapper should * adhere. Supported values are * &lt;ul&gt; * &lt;li&gt; &#123;@code default&#125;: the mapper uses no component model, instances are * typically retrieved via &#123;@link Mappers#getMapper(Class)&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code cdi&#125;: the generated mapper is an application-scoped CDI bean and * can be retrieved via &#123;@code @Inject&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code spring&#125;: the generated mapper is a Spring bean and * can be retrieved via &#123;@code @Autowired&#125;&lt;/li&gt; * &lt;li&gt; * &#123;@code jsr330&#125;: the generated mapper is annotated with &#123;@code @javax.inject.Named&#125; and * &#123;@code @Singleton&#125;, and can be retrieved via &#123;@code @Inject&#125;&lt;/li&gt; * &lt;/ul&gt; * The method overrides an unmappedTargetPolicy set in a central configuration set * by &#123;@link #config() &#125; * * @return The component model for the generated mapper. */ String componentModel() default "default";&#125; Data type conversions 可以自动类型转换的常见的类型及其他们的包装类mapstruct都是进行自动类型转换的。同时有些类型是可以转成string类型的。mapstruct也是支持自定义类型的转换的@Mapper(uses = 自定义转换类.class)当然也支持格式化，但是格式化的的参数同java.text.DecimalFormat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** * @author yinbingyu * @since 2019/06/04 */@Mapper(uses = BooleanStrategy.class)public interface InventoryMapper &#123; InventoryMapper INSTANCE = Mappers.getMapper(InventoryMapper.class); /** * DO 转 DTO * * @param inventoryDO * @return */ @Mappings(&#123; @Mapping(target = "actualOutWarehouseDate", dateFormat = "yyyy-MM-dd HH:mm:ss"), @Mapping(target = "totalPrice", numberFormat = "\\u00A4#,###,###.00"), @Mapping(target = "inWaySubStatusEnum", source = "inventoryStatusEnum") &#125;) InventoryDTO doToDto(InventoryDO inventoryDO); /** * dto 转 DO * ignore可以忽略某个字段@BeanMapping可以忽略 所有满足自动转换的字段 * * @param inventoryDTO * @return */ @Mappings(&#123; @Mapping(target = "actualOutWarehouseDate", dateFormat = "yyyy-MM-dd HH:mm:ss"), @Mapping(target = "inventoryStatusEnum", source = "inWaySubStatusEnum"), @Mapping(target = "vin", ignore = true) &#125;) InventoryDO dtoToDo(InventoryDTO inventoryDTO);&#125;/** * 自定义类型转换策略 * * @author yinbingyu * @since 2019/06/04 */public class BooleanStrategy &#123; public String booleanToString(Boolean value) &#123; if (value == null) &#123; return null; &#125; return value ? "是" : "否"; &#125; public Integer booleanToInteger(Boolean value) &#123; if (value == null) &#123; return null; &#125; return value ? 1 : 0; &#125; public Boolean IntegerToBoolean(Integer value) &#123; if (value == null) &#123; return null; &#125; return value == 0 ? false : true; &#125;&#125;// mapstuct自动实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-15T14:03:23+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class InventoryMapperImpl implements InventoryMapper &#123; private final BooleanStrategy booleanStrategy = new BooleanStrategy(); @Override public InventoryDTO doToDto(InventoryDO inventoryDO) &#123; if ( inventoryDO == null ) &#123; return null; &#125; InventoryDTOBuilder inventoryDTO = InventoryDTO.builder(); if ( inventoryDO.getInventoryStatusEnum() != null ) &#123; inventoryDTO.inWaySubStatusEnum( inventoryDO.getInventoryStatusEnum().name() ); &#125; inventoryDTO.vin( inventoryDO.getVin() ); inventoryDTO.inventoryMainStatus( inventoryDO.getInventoryMainStatus() ); inventoryDTO.inventorySubStatus( inventoryDO.getInventorySubStatus() ); inventoryDTO.actualStorageDate( inventoryDO.getActualStorageDate() ); if ( inventoryDO.getActualOutWarehouseDate() != null ) &#123; inventoryDTO.actualOutWarehouseDate( new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).format( inventoryDO.getActualOutWarehouseDate() ) ); &#125; if ( inventoryDO.getTotalPrice() != null ) &#123; inventoryDTO.totalPrice( createDecimalFormat( "\u00A4#,###,###.00" ).format( inventoryDO.getTotalPrice() ) ); &#125; inventoryDTO.canSale( booleanStrategy.booleanToString( inventoryDO.getCanSale() ) ); inventoryDTO.canMove( booleanStrategy.booleanToInteger( inventoryDO.getCanMove() ) ); return inventoryDTO.build(); &#125; @Override public InventoryDO dtoToDo(InventoryDTO inventoryDTO) &#123; if ( inventoryDTO == null ) &#123; return null; &#125; InventoryDOBuilder inventoryDO = InventoryDO.builder(); if ( inventoryDTO.getInWaySubStatusEnum() != null ) &#123; inventoryDO.inventoryStatusEnum( Enum.valueOf( InventoryStatusEnum.class, inventoryDTO.getInWaySubStatusEnum() ) ); &#125; inventoryDO.inventoryMainStatus( inventoryDTO.getInventoryMainStatus() ); inventoryDO.inventorySubStatus( inventoryDTO.getInventorySubStatus() ); inventoryDO.actualStorageDate( inventoryDTO.getActualStorageDate() ); try &#123; if ( inventoryDTO.getActualOutWarehouseDate() != null ) &#123; inventoryDO.actualOutWarehouseDate( new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).parse( inventoryDTO.getActualOutWarehouseDate() ) ); &#125; &#125; catch ( ParseException e ) &#123; throw new RuntimeException( e ); &#125; if ( inventoryDTO.getTotalPrice() != null ) &#123; inventoryDO.totalPrice( new BigDecimal( inventoryDTO.getTotalPrice() ) ); &#125; if ( inventoryDTO.getCanSale() != null ) &#123; inventoryDO.canSale( Boolean.parseBoolean( inventoryDTO.getCanSale() ) ); &#125; inventoryDO.canMove( booleanStrategy.IntegerToBoolean( inventoryDTO.getCanMove() ) ); return inventoryDO.build(); &#125; private DecimalFormat createDecimalFormat( String numberFormat ) &#123; DecimalFormat df = new DecimalFormat( numberFormat ); df.setParseBigDecimal( true ); return df; &#125;&#125; ps:那些需要可能失去精度的转换可以控制他们的方案，是否需要抛异常默认是 ReportingPolicy typeConversionPolicy() default ReportingPolicy.IGNORE; 自定义类型转换 一种是上面说到的@Mapper(uses = BooleanStrategy.class) 另外一种是需要自定义多个相同的映射法则的时候，可以使用@Qualifier注解 默认值的问题defaultValue 必须是target和source必须都有的情况下才可以赋值默认值，只有target没有source的时候，可以使用constant 1234567891011121314@Mapper(uses = StringListMapper.class)public interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target = "stringProperty", source = "stringProp", defaultValue = "undefined") @Mapping(target = "longProperty", source = "longProp", defaultValue = "-1") @Mapping(target = "stringConstant", constant = "Constant Value") @Mapping(target = "integerConstant", constant = "14") @Mapping(target = "longWrapperConstant", constant = "3001") @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014") @Mapping(target = "stringListConstants", constant = "jack-jill-tom") Target sourceToTarget(Source s);&#125; 官网说明 If s.getStringProp() == null, then the target property stringProperty will be set to “undefined” instead of applying the value from s.getStringProp(). If s.getLongProperty() == null, then the target property longProperty will be set to -1. The String “Constant Value” is set as is to the target property stringConstant. The value “3001” is type-converted to the Long (wrapper) class of target property longWrapperConstant. Date properties also require a date format. The constant “jack-jill-tom” demonstrates how the hand-written class StringListMapper is invoked to map the dash-separated list into a List. Mapping Collection 原理是遍历source collection然后转换类型，put到target collection中如果是可以自动转换的则自动转换，同date type conversion；若是无法自动转换的，则会查看是否有可以调用的类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Mapper(imports = Date.class)public interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 基本类型collection的转换 * * @param integers * @return */ Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers); /** * 调用存在已有方法的转换 * * @param cars * @return */ List&lt;CarDTO&gt; carsToCarDtos(List&lt;CarDO&gt; cars); /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ @Mapping(target = "userName", constant = "yby") @Mapping(target = "modelColor", source = "modelColor", defaultValue = "标致") @Mapping(target = "createTime", dateFormat = "yyyy-MM-dd HH:mm:ss", expression = "java(new Date())") CarDTO doToDTO(CarDO carDO);&#125;// mapstruct实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:27:05+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class CarMapperImpl implements CarMapper &#123; @Override public Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers) &#123; if ( integers == null ) &#123; return null; &#125; Set&lt;String&gt; set = new HashSet&lt;String&gt;( Math.max( (int) ( integers.size() / .75f ) + 1, 16 ) ); for ( Integer integer : integers ) &#123; set.add( String.valueOf( integer ) ); &#125; return set; &#125; @Override public List&lt;CarDTO&gt; carsToCarDtos(List&lt;CarDO&gt; cars) &#123; if ( cars == null ) &#123; return null; &#125; List&lt;CarDTO&gt; list = new ArrayList&lt;CarDTO&gt;( cars.size() ); for ( CarDO carDO : cars ) &#123; list.add( doToDTO( carDO ) ); &#125; return list; &#125; @Override public CarDTO doToDTO(CarDO carDO) &#123; if ( carDO == null ) &#123; return null; &#125; CarDTO carDTO = new CarDTO(); if ( carDO.getModelColor() != null ) &#123; carDTO.setModelColor( carDO.getModelColor() ); &#125; else &#123; carDTO.setModelColor( "标致" ); &#125; if ( carDO.getNewCarGuidePrice() != null ) &#123; carDTO.setNewCarGuidePrice( BigDecimal.valueOf( carDO.getNewCarGuidePrice() ) ); &#125; carDTO.setBrandCode( carDO.getBrandCode() ); carDTO.setBrandName( carDO.getBrandName() ); carDTO.setSeriesCode( carDO.getSeriesCode() ); carDTO.setSeriesName( carDO.getSeriesName() ); carDTO.setModelCode( carDO.getModelCode() ); carDTO.setModelName( carDO.getModelName() ); carDTO.setModelColorCode( carDO.getModelColorCode() ); carDTO.setUserName( "yby" ); carDTO.setCreateTime( new Date() ); return carDTO; &#125;&#125; 没有可以调用的方法，则mapstruct尝试自己实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author yinbingyu * @since 2019/07/25 */@Mapperpublic interface WarehouseMapper &#123; WarehouseMapper INSTANCE = Mappers.getMapper(WarehouseMapper.class); /** * DTO转为VO * * @param warehouseValidDTOList * @return */ List&lt;WarehouseValidPageVO&gt; dtoToVo(List&lt;WarehouseValidDTO&gt; warehouseValidDTOList);&#125;// mapstruct 自己实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T15:53:04+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class WarehouseMapperImpl implements WarehouseMapper &#123; @Override public List&lt;WarehouseValidPageVO&gt; dtoToVo(List&lt;WarehouseValidDTO&gt; warehouseValidDTOList) &#123; if ( warehouseValidDTOList == null ) &#123; return null; &#125; List&lt;WarehouseValidPageVO&gt; list = new ArrayList&lt;WarehouseValidPageVO&gt;( warehouseValidDTOList.size() ); for ( WarehouseValidDTO warehouseValidDTO : warehouseValidDTOList ) &#123; list.add( warehouseValidDTOToWarehouseValidPageVO( warehouseValidDTO ) ); &#125; return list; &#125; protected WarehouseValidPageVO warehouseValidDTOToWarehouseValidPageVO(WarehouseValidDTO warehouseValidDTO) &#123; if ( warehouseValidDTO == null ) &#123; return null; &#125; WarehouseValidPageVO warehouseValidPageVO = new WarehouseValidPageVO(); warehouseValidPageVO.setId( warehouseValidDTO.getId() ); warehouseValidPageVO.setWarehouseNo( warehouseValidDTO.getWarehouseNo() ); warehouseValidPageVO.setWarehouseName( warehouseValidDTO.getWarehouseName() ); warehouseValidPageVO.setPlateValid( warehouseValidDTO.getPlateValid() ); return warehouseValidPageVO; &#125;&#125; map 12345678910111213141516171819202122232425262728293031public interface SourceTargetMapper &#123; @MapMapping(valueDateFormat = "dd.MM.yyyy") Map&lt;String, String&gt; longDateMapToStringStringMap(Map&lt;Long, Date&gt; source);&#125;// mapstruct自己实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:35:22+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class SourceTargetMapperImpl implements SourceTargetMapper &#123; @Override public Map&lt;String, String&gt; longDateMapToStringStringMap(Map&lt;Long, Date&gt; source) &#123; if ( source == null ) &#123; return null; &#125; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;( Math.max( (int) ( source.size() / .75f ) + 1, 16 ) ); for ( java.util.Map.Entry&lt;Long, Date&gt; entry : source.entrySet() ) &#123; String key = new DecimalFormat( "" ).format( entry.getKey() ); String value = new SimpleDateFormat( "dd.MM.yyyy" ).format( entry.getValue() ); map.put( key, value ); &#125; return map; &#125;&#125; stream类型转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Mapper(imports = Date.class)public interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); /** * 单个参数的直接使用 * * @param carDO source do * @return target dto */ @Mapping(target = "userName", constant = "yby") @Mapping(target = "modelColor", source = "modelColor", defaultValue = "标致") @Mapping(target = "createTime", dateFormat = "yyyy-MM-dd HH:mm:ss", expression = "java(new Date())") CarDTO doToDTO(CarDO carDO); /** * stream的类型转换 * * @param integers * @return */ Set&lt;String&gt; integerStreamToStringSet(Stream&lt;Integer&gt; integers); /** * stream的类型转换 * * @param cars * @return */ List&lt;CarDTO&gt; carsStreamToCarDtos(Stream&lt;CarDO&gt; cars);&#125;// mapstruct 实现@Generated( value = "org.mapstruct.ap.MappingProcessor", date = "2019-07-30T19:38:25+0800", comments = "version: 1.3.0.Final, compiler: javac, environment: Java 1.8.0_101 (Oracle Corporation)")public class CarMapperImpl implements CarMapper &#123; @Override public Set&lt;String&gt; integerStreamToStringSet(Stream&lt;Integer&gt; integers) &#123; if ( integers == null ) &#123; return null; &#125; return integers.map( integer -&gt; String.valueOf( integer ) ) .collect( Collectors.toCollection( HashSet&lt;String&gt;::new ) ); &#125; @Override public List&lt;CarDTO&gt; carsStreamToCarDtos(Stream&lt;CarDO&gt; cars) &#123; if ( cars == null ) &#123; return null; &#125; return cars.map( carDO -&gt; doToDTO( carDO ) ) .collect( Collectors.toCollection( ArrayList&lt;CarDTO&gt;::new ) ); &#125; @Override public CarDTO doToDTO(CarDO carDO) &#123; ..... &#125;&#125; Expressions 格式 expression = &quot;java( 表达式 )&quot; 123456789@Mapperpublic interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target = &quot;timeAndFormat&quot;, expression = &quot;java( new org.sample.TimeAndFormat( s.getTime(), s.getFormat() ) )&quot;) Target sourceToTarget(Source s);&#125; 其中使用的类名必须要指定到全路径，若是使用比较麻烦，也可以使用imports 123456789101112131415161718@Mapper(imports = &#123;JSON.class, String.class, OptimusConfig.class&#125;)public interface TicketOuterMapper &#123; /** * 个人牌订单保险信息组装 * * @param plateInfoDO 个人牌保险信息 * @param insuranceCreateDTO 创建保险的原始目标信息 * @return */ @Mappings(&#123; @Mapping(target = "insuranceIdentityCardUrlList", expression = "java(JSON.parseArray(plateInfoDO.getBuyerIdPicList(), String.class))"), @Mapping(target = "financingSite", expression = "java(OptimusConfig.getValue(\"org_name\"))") &#125;) InsuranceCreateDTO personInfoDoToDto(@MappingTarget InsuranceCreateDTO insuranceCreateDTO, PersonalPlateInfoDO plateInfoDO);&#125; Default Expressions 12345678910imports java.util.UUID;@Mapper( imports = UUID.class )public interface SourceTargetMapper &#123; SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class ); @Mapping(target="id", source="sourceId", defaultExpression = "java( UUID.randomUUID().toString() )") Target sourceToTarget(Source s);&#125;]]></content>
      <categories>
        <category>mapstruct</category>
      </categories>
      <tags>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Spring AOP的分布式锁简单实现]]></title>
    <url>%2F2019%2F07%2F23%2Fdislock%2F</url>
    <content type="text"><![CDATA[防止数据的并发操作出现数据不一致，保证操作是幂等的，我们可以对对象加锁、方法加锁，例如synchronized、ReentrantLock等，但是上述Jdk提供的锁时基于内存的，在分布式环境下是不适用的，那么在分布式环境下该如何实现锁操作呢？分布式环境下需要保证集群中对同一数据、方法等操作状态，所以需要把状态单独存储，分布式锁的实现常用方式是基于缓存或者ZK，常用分布式缓存包括Redis和memcached,通过在缓存中设置同一个key和过期时间实现集群中拿到的状态是一致的，ZK是分布式锁实现是基于ZK的临时顺序节点，通过判断同一name下节点是否是最小节点确定是否获取到锁。本文不具体介绍如何实现缓存的写入和删除或者ZK的临时顺序节点创建等实现，主要针对怎么利用Spring AOP消除冗余的if…else,try{}catch(){}等代码，至于为什么，举个正常写一下锁调用的和利用AOP实现的简单对比。 正常写法 public String test() { final String lockKey = "lock_key"; if (!DistributedLock.getInstance().lock(lockKey, 10, TimeUnit.SECONDS)) { // 没有获取到锁, 返回 } try { // 获取到锁, 进行业务逻辑 // ... } finally { // 释放锁 DistributedLock.getInstance().unlock(lockKey); } return "ok"; } AOP实现 @Lock(prefix="lock_key") public String test() { return "ok"; } 看上面两个对比，是不是发现下面的写法很简洁，不用重复写相同的代码了，下面们一下具体实现，其实主要是@Lock注解的定义，和利用AOP对注解的拦截 @Lock package com.github.lock.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @author wangdongbo * @since 2019/7/22. */ @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Lock { /** * 锁前缀, 为空时取'classname_method_' */ String prefix() default ""; /** * 方法参数名，支持方法中的入参，支持方法参数是对象时对象属性的字段 * 不支持集合/数组参数 */ String[] parameter() default {}; /** * 锁定时间 */ int lockSeconds() default 10; /** * 是否重试，默认重试 */ boolean retry() default true; /** * 重试次数，默认为1，retry为true时可用 */ int retryCount() default 1; /** * 没拿到锁时等待多久后重试，retry为true时可用 */ int tryLockSeconds() default 10; /** * 提示 */ String desc() default "数据正在操作中，请稍后再试"; } LockResolver.java package com.github.lock.resolver; import com.github.lock.annotation.Lock; import com.github.lock.exception.LockException; import com.github.lock.util.UUIDUtil; import com.github.lock.way.DistributedLock; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.ArrayUtils; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.LocalVariableTableParameterNameDiscoverer; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.List; import java.util.stream.Stream; /** * @author wangdongbo * @since 2019/7/22. */ @Slf4j @Aspect @Order(1) @Component public class LockResolver { private static final String DOT = "."; private static final String DOT_SPLIT = "\\."; @Autowired private DistributedLock distributedLock; private static LocalVariableTableParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer(); @Pointcut("@annotation(com.github.lock.annotation.Lock)") public void lockAspectMethod() { } @Around("lockAspectMethod()") public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = methodSignature.getMethod(); if (method == null) { throw new LockException("method is empty"); } Lock lock = method.getAnnotation(Lock.class); String prefix; if (!StringUtils.isEmpty(lock.prefix())) { prefix = lock.prefix(); } else { prefix = joinPoint.getTarget().getClass().getSimpleName() + "_" + method.getName() + "_"; } String lockKey = prefix + getArgsConcat(method, lock.parameter(), joinPoint.getArgs()); String requestId = UUIDUtil.getID(); try { if (lock.retry()) { int count = lock.retryCount(); for (int i = 0; i &lt; count; i++) { if (distributedLock.tryLock(lockKey, requestId, lock.lockSeconds(), lock.tryLockSeconds())) { return joinPoint.proceed(); } } } else if (distributedLock.lock(lockKey, requestId, lock.lockSeconds())) { return joinPoint.proceed(); } throw new LockException(lock.desc()); } catch (Throwable e) { log.warn("add lock error:{}", e.getMessage(), e); throw new LockException(e.getMessage(), e); } finally { distributedLock.unlock(lockKey, requestId); } } private String getArgsConcat(Method method, String[] parameter, Object[] args) { String[] params = parameterNameDiscoverer.getParameterNames(method); if (ArrayUtils.isEmpty(parameter)) { return ""; } List&lt;Object&gt; list = Lists.newArrayListWithCapacity(parameter.length); Stream.of(parameter).forEach(s -&gt; { if (s.contains(DOT)) { list.add(parseObj(s, params, args)); } else { int idx = ArrayUtils.indexOf(params, s); list.add(args[idx]); } }); return Joiner.on("_").join(list); } private Object parseObj(String parameter, String[] params, Object[] args) { String firstField = parameter.split(DOT_SPLIT)[0]; int idx = ArrayUtils.indexOf(params, firstField); Object value = args[idx]; Class valueClass = value.getClass(); Object[] fields = ArrayUtils.remove(parameter.split(DOT_SPLIT), 0); for (Object field : fields) { try { Field nextField = valueClass.getDeclaredField(String.valueOf(field)); nextField.setAccessible(true); value = nextField.get(value); valueClass = value.getClass(); } catch (NoSuchFieldException | IllegalAccessException e) { log.error(e.getMessage(), e); } } return value; } } 提供一个锁接口，具体可以根据自己的代码实现具体的功能。 DistributedLock.java package com.github.lock.way; /** * @author wangdongbo * @since 2019/7/22. */ public interface DistributedLock { /** * 加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @return 是否加锁成功 */ boolean lock(String lockKey, String requestId, int seconds); /** * 尝试加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @param trySeconds 拿不到锁,等待多久之后再次尝试加锁[秒] * @return 是否加锁成功 */ boolean tryLock(String lockKey, String requestId, int seconds, int trySeconds); /** * 释放锁 * * @param lockKey key * @param requestId 唯一请求ID * @return 是否成功释放锁 */ boolean unlock(String lockKey, String requestId); } 以上代码就是主要逻辑代码，具体代码实现可以参考工程: 传送门]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存简单介绍]]></title>
    <url>%2F2019%2F07%2F19%2Fcachedesc%2F</url>
    <content type="text"><![CDATA[缓存概念缓存穿透缓存穿透是指攻击者不断发起查询缓存和数据库中都没有的数据，导致压力全部落在数据库，导致数据库压力过大。 解决方案： 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。 缓存击穿缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 解决方案 设置热点数据永远不过期。 读数据库时加互斥锁，写入缓存，其他等待线程就可以从缓存读取 缓存雪崩缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。 设置热点数据永远不过期。 内存缓存框架 比较项 ConcurrentHashMap LRUMap Ehcache Guava Cache Caffeine 读写性能 很好，分段锁 一般，全局加锁 好 好，需要做淘汰操作 很好 淘汰算法 无 LRU，一般 支持多种淘汰算法,LRU,LFU,FIFO LRU，一般 W-TinyLFU, 很好 功能丰富程度 功能比较简单 功能比较单一 功能很丰富 功能很丰富，支持刷新和虚引用等 功能和Guava Cache类似 工具大小 jdk自带类，很小 基于LinkedHashMap，较小 很大，最新版本1.4MB 是Guava工具类中的一个小部分，较小 一般，最新版本644KB 是否持久化 否 否 是 否 否 是否支持集群 否 否 是 否 否 对于ConcurrentHashMap来说，比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是jdk自带的类，在各种框架中依然有大量的使用,比如我们可以用来缓存我们反射的Method,Field等等;也可以缓存一些链接，防止其重复建立。在Caffeine中也是使用的ConcurrentHashMap来存储元素。 对于LRUMap来说，如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。 对于Ehcache来说，由于其jar包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代Ehcache。 对于Guava Cache来说，Guava这个jar包在很多Java应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解Caffeine的情况下可以选择Guava Cache。 总结一下:如果不需要淘汰算法则选择ConcurrentHashMap，如果需要淘汰算法和一些丰富的API，这里推荐选择Caffeine。 分布式缓存框架这里选取比较出名的分布式缓存来作为比较，Memcached，Redis. 不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。 比较项 Memcached Redis 数据结构 只支持简单的Key-Value结构 String,Hash, List, Set, Sorted Set 持久化 不支持 支持 容量大小 数据纯内存，数据存储不宜过多 数据全内存，资源成本考量不宜超过100GB 读写性能 很高 很高(RT0.5ms左右) Memcached：其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。 Redis:支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。 总结:如果服务对延迟比较敏感，Map/Set数据也比较多的话，比较适合Redis。]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>redis</tag>
        <tag>memcached</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean 生命周期]]></title>
    <url>%2F2019%2F07%2F19%2Fspringbean%2F</url>
    <content type="text"><![CDATA[如下图]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Velocity]]></title>
    <url>%2F2019%2F07%2F19%2Fvelocity%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下Velocity渲染模板时最基本的代码 引入Velocity Maven信息 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.google.common.base.Charsets;import com.google.common.collect.Maps;import com.github.pdf.tools.exception.VelocityException;import net.sf.cglib.beans.BeanMap;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import org.apache.velocity.app.VelocityEngine;import java.io.StringWriter;import java.util.Collections;import java.util.Map;import java.util.Objects;import java.util.Properties;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class VelocityTemplate extends AbstractTemplate &#123; private static final Map&lt;String, VelocityEngine&gt; ENGINE_MAP = new ConcurrentHashMap&lt;&gt;(16); private static VelocityEngine getEngine(String templatePath) &#123; if (ENGINE_MAP.containsKey(templatePath)) &#123; return ENGINE_MAP.get(templatePath); &#125; Properties properties = new Properties(); properties.setProperty(Velocity.OUTPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.INPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, templatePath); VelocityEngine velocityEngine = new VelocityEngine(properties); ENGINE_MAP.put(templatePath, velocityEngine); return velocityEngine; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; VelocityContext velocityContext = new VelocityContext(Objects.nonNull(data) ? Maps.newHashMap(BeanMap.create(data)) : Collections.emptyMap()); Template template = getEngine(templatePath).getTemplate(templateName, Charsets.UTF_8.toString()); StringWriter writer = new StringWriter(); template.merge(velocityContext, writer); writer.flush(); return writer.toString(); &#125; catch (Exception e) &#123; throw new VelocityException("Velocity exception", e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Freemarker]]></title>
    <url>%2F2019%2F07%2F19%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下FreeMarker渲染模板时最基本的代码 引入FreeMarker Maven信息 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import com.google.common.base.Charsets;import com.github.pdf.tools.exception.FreeMarkerException;import freemarker.cache.FileTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateExceptionHandler;import java.io.File;import java.io.IOException;import java.io.StringWriter;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class FreeMarkerTemplate extends AbstractTemplate &#123; private static Map&lt;String, FileTemplateLoader&gt; FILE_TEMPLATE_LOADER_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Map&lt;String, Configuration&gt; CONFIGURATION_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Configuration getConfiguration(String templatePath) &#123; if (CONFIGURATION_CACHE.get(templatePath) != null) &#123; return CONFIGURATION_CACHE.get(templatePath); &#125; Configuration config = new Configuration(Configuration.VERSION_2_3_25); config.setDefaultEncoding(Charsets.UTF_8.toString()); config.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); config.setLogTemplateExceptions(false); FileTemplateLoader fileTemplateLoader; try &#123; if (FILE_TEMPLATE_LOADER_CACHE.containsKey(templatePath)) &#123; fileTemplateLoader = FILE_TEMPLATE_LOADER_CACHE.get(templatePath); &#125; else &#123; fileTemplateLoader = new FileTemplateLoader(new File(templatePath)); &#125; &#125; catch (IOException e) &#123; throw new FreeMarkerException("fileTemplateLoader init error!", e); &#125; config.setTemplateLoader(fileTemplateLoader); CONFIGURATION_CACHE.put(templatePath, config); return config; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; Template template = getConfiguration(templatePath).getTemplate(templateName); StringWriter writer = new StringWriter(); template.process(data, writer); writer.flush(); return writer.toString(); &#125; catch (Exception ex) &#123; throw new FreeMarkerException("FreeMarkerUtil process fail", ex); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F07%2F19%2Flinux%2F</url>
    <content type="text"><![CDATA[1grep | zgrep]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
