<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mapstruct简介和使用]]></title>
    <url>%2F2019%2F07%2F23%2Fmapstruct%2F</url>
    <content type="text"><![CDATA[简介mapstrct是一个很好注释处理的框架，解决繁琐domain之间值的转换，节约开发的时间，同时相对应copyProperty的好处是没有使用反射技术，使性能更优。mapstrut一共两个主要的包，org.mapstruct.mapstruct包含里面常用的注释，org.mapstruct.mapstruct-processor处理注释的实现。 官方文档文档传送门 API &amp; 使用MAVEN123456789101112131415161718192021222324252627&lt;!-- 指定版本 --&gt;&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;!-- 引入依赖 --&gt;&lt;dependencies&gt; &lt;!--mapstruct主键--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mapstruct插件 可以直接点击查看mapstruct的实现类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;dependency&gt; &lt;!-- mapstruct实现类执行器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;private&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本使用 定义一个接口，并使用@Mapper 定义一个转换的方法。方法上常用的注解 12@Mapping(target="",source="")、@Mappings(&#123;@Mapping(target="",source=""),@Mapping(target="",source="")&#125;) ps:如果target和source字段相同的则无需使用注解，mapstruct会自动为我们copy值的方法名称上面如果有个可以忽略自动引入的注解@BeanMapping(ignoreByDefault=true),可以防止target copy source的时候报错 类型的转换有三种特殊的 常见基本类型的不同，@Mapping会自动转换 bean不同的类型的转换 会创建或者调用其他的方法 collection类型，如果相同的类型他会重新创建一个新的实例集合，并且赋值，如果不同的则会分开进行赋值。ps:具体的内容请看其他的评论 mapstruct可以自定义类型转换，只要入参的类型和返回值于需要的一直，就会自动调用。同时mapstruct的定义不仅仅可以使用接口，也可以使用抽象类。 mapstruct支持多个参数的，如果名字一样则会自动映射，不同则需要使用@Mapping，如果多个参数的都有target的属性名需要制定是哪个source的属性名，否则会报错mapstruct可以直接将一个基本类型的字段直接映射对应的bean字段 mapstruct可以更新instance，而不是create instance, 使用@MappingTarget]]></content>
      <categories>
        <category>mapstruct</category>
      </categories>
      <tags>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Spring AOP的分布式锁简单实现]]></title>
    <url>%2F2019%2F07%2F23%2Fdislock%2F</url>
    <content type="text"><![CDATA[防止数据的并发操作出现数据不一致，保证操作是幂等的，我们可以对对象加锁、方法加锁，例如synchronized、ReentrantLock等，但是上述Jdk提供的锁时基于内存的，在分布式环境下是不适用的，那么在分布式环境下该如何实现锁操作呢？分布式环境下需要保证集群中对同一数据、方法等操作状态，所以需要把状态单独存储，分布式锁的实现常用方式是基于缓存或者ZK，常用分布式缓存包括Redis和memcached,通过在缓存中设置同一个key和过期时间实现集群中拿到的状态是一致的，ZK是分布式锁实现是基于ZK的临时顺序节点，通过判断同一name下节点是否是最小节点确定是否获取到锁。本文不具体介绍如何实现缓存的写入和删除或者ZK的临时顺序节点创建等实现，主要针对怎么利用Spring AOP消除冗余的if…else,try{}catch(){}等代码，至于为什么，举个正常写一下锁调用的和利用AOP实现的简单对比。 正常写法 public String test() { final String lockKey = "lock_key"; if (!DistributedLock.getInstance().lock(lockKey, 10, TimeUnit.SECONDS)) { // 没有获取到锁, 返回 } try { // 获取到锁, 进行业务逻辑 // ... } finally { // 释放锁 DistributedLock.getInstance().unlock(lockKey); } return "ok"; } AOP实现 @Lock(prefix="lock_key") public String test() { return "ok"; } 看上面两个对比，是不是发现下面的写法很简洁，不用重复写相同的代码了，下面们一下具体实现，其实主要是@Lock注解的定义，和利用AOP对注解的拦截 @Lock package com.github.lock.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @author wangdongbo * @since 2019/7/22. */ @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Lock { /** * 锁前缀, 为空时取'classname_method_' */ String prefix() default ""; /** * 方法参数名，支持方法中的入参，支持方法参数是对象时对象属性的字段 * 不支持集合/数组参数 */ String[] parameter() default {}; /** * 锁定时间 */ int lockSeconds() default 10; /** * 是否重试，默认重试 */ boolean retry() default true; /** * 重试次数，默认为1，retry为true时可用 */ int retryCount() default 1; /** * 没拿到锁时等待多久后重试，retry为true时可用 */ int tryLockSeconds() default 10; /** * 提示 */ String desc() default "数据正在操作中，请稍后再试"; } LockResolver.java package com.github.lock.resolver; import com.github.lock.annotation.Lock; import com.github.lock.exception.LockException; import com.github.lock.util.UUIDUtil; import com.github.lock.way.DistributedLock; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.ArrayUtils; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.LocalVariableTableParameterNameDiscoverer; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.List; import java.util.stream.Stream; /** * @author wangdongbo * @since 2019/7/22. */ @Slf4j @Aspect @Order(1) @Component public class LockResolver { private static final String DOT = "."; private static final String DOT_SPLIT = "\\."; @Autowired private DistributedLock distributedLock; private static LocalVariableTableParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer(); @Pointcut("@annotation(com.github.lock.annotation.Lock)") public void lockAspectMethod() { } @Around("lockAspectMethod()") public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = methodSignature.getMethod(); if (method == null) { throw new LockException("method is empty"); } Lock lock = method.getAnnotation(Lock.class); String prefix; if (!StringUtils.isEmpty(lock.prefix())) { prefix = lock.prefix(); } else { prefix = joinPoint.getTarget().getClass().getSimpleName() + "_" + method.getName() + "_"; } String lockKey = prefix + getArgsConcat(method, lock.parameter(), joinPoint.getArgs()); String requestId = UUIDUtil.getID(); try { if (lock.retry()) { int count = lock.retryCount(); for (int i = 0; i &lt; count; i++) { if (distributedLock.tryLock(lockKey, requestId, lock.lockSeconds(), lock.tryLockSeconds())) { return joinPoint.proceed(); } } } else if (distributedLock.lock(lockKey, requestId, lock.lockSeconds())) { return joinPoint.proceed(); } throw new LockException(lock.desc()); } catch (Throwable e) { log.warn("add lock error:{}", e.getMessage(), e); throw new LockException(e.getMessage(), e); } finally { distributedLock.unlock(lockKey, requestId); } } private String getArgsConcat(Method method, String[] parameter, Object[] args) { String[] params = parameterNameDiscoverer.getParameterNames(method); if (ArrayUtils.isEmpty(parameter)) { return ""; } List&lt;Object&gt; list = Lists.newArrayListWithCapacity(parameter.length); Stream.of(parameter).forEach(s -&gt; { if (s.contains(DOT)) { list.add(parseObj(s, params, args)); } else { int idx = ArrayUtils.indexOf(params, s); list.add(args[idx]); } }); return Joiner.on("_").join(list); } private Object parseObj(String parameter, String[] params, Object[] args) { String firstField = parameter.split(DOT_SPLIT)[0]; int idx = ArrayUtils.indexOf(params, firstField); Object value = args[idx]; Class valueClass = value.getClass(); Object[] fields = ArrayUtils.remove(parameter.split(DOT_SPLIT), 0); for (Object field : fields) { try { Field nextField = valueClass.getDeclaredField(String.valueOf(field)); nextField.setAccessible(true); value = nextField.get(value); valueClass = value.getClass(); } catch (NoSuchFieldException | IllegalAccessException e) { log.error(e.getMessage(), e); } } return value; } } 提供一个锁接口，具体可以根据自己的代码实现具体的功能。 DistributedLock.java package com.github.lock.way; /** * @author wangdongbo * @since 2019/7/22. */ public interface DistributedLock { /** * 加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @return 是否加锁成功 */ boolean lock(String lockKey, String requestId, int seconds); /** * 尝试加锁 * * @param lockKey key * @param requestId 唯一请求ID * @param seconds 锁定时间[秒] * @param trySeconds 拿不到锁,等待多久之后再次尝试加锁[秒] * @return 是否加锁成功 */ boolean tryLock(String lockKey, String requestId, int seconds, int trySeconds); /** * 释放锁 * * @param lockKey key * @param requestId 唯一请求ID * @return 是否成功释放锁 */ boolean unlock(String lockKey, String requestId); } 以上代码就是主要逻辑代码，具体代码实现可以参考工程: 传送门]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存简单介绍]]></title>
    <url>%2F2019%2F07%2F19%2Fcachedesc%2F</url>
    <content type="text"><![CDATA[缓存概念缓存穿透缓存穿透是指攻击者不断发起查询缓存和数据库中都没有的数据，导致压力全部落在数据库，导致数据库压力过大。 解决方案： 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。 缓存击穿缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 解决方案 设置热点数据永远不过期。 读数据库时加互斥锁，写入缓存，其他等待线程就可以从缓存读取 缓存雪崩缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。 设置热点数据永远不过期。 内存缓存框架 比较项 ConcurrentHashMap LRUMap Ehcache Guava Cache Caffeine 读写性能 很好，分段锁 一般，全局加锁 好 好，需要做淘汰操作 很好 淘汰算法 无 LRU，一般 支持多种淘汰算法,LRU,LFU,FIFO LRU，一般 W-TinyLFU, 很好 功能丰富程度 功能比较简单 功能比较单一 功能很丰富 功能很丰富，支持刷新和虚引用等 功能和Guava Cache类似 工具大小 jdk自带类，很小 基于LinkedHashMap，较小 很大，最新版本1.4MB 是Guava工具类中的一个小部分，较小 一般，最新版本644KB 是否持久化 否 否 是 否 否 是否支持集群 否 否 是 否 否 对于ConcurrentHashMap来说，比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是jdk自带的类，在各种框架中依然有大量的使用,比如我们可以用来缓存我们反射的Method,Field等等;也可以缓存一些链接，防止其重复建立。在Caffeine中也是使用的ConcurrentHashMap来存储元素。 对于LRUMap来说，如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。 对于Ehcache来说，由于其jar包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择Ehcache。笔者没怎么使用过这个缓存，如果要选择的话，可以选择分布式缓存来替代Ehcache。 对于Guava Cache来说，Guava这个jar包在很多Java应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解Caffeine的情况下可以选择Guava Cache。 总结一下:如果不需要淘汰算法则选择ConcurrentHashMap，如果需要淘汰算法和一些丰富的API，这里推荐选择Caffeine。 分布式缓存框架这里选取比较出名的分布式缓存来作为比较，Memcached，Redis. 不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。 比较项 Memcached Redis 数据结构 只支持简单的Key-Value结构 String,Hash, List, Set, Sorted Set 持久化 不支持 支持 容量大小 数据纯内存，数据存储不宜过多 数据全内存，资源成本考量不宜超过100GB 读写性能 很高 很高(RT0.5ms左右) Memcached：其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。 Redis:支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。 总结:如果服务对延迟比较敏感，Map/Set数据也比较多的话，比较适合Redis。]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>redis</tag>
        <tag>memcached</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean 生命周期]]></title>
    <url>%2F2019%2F07%2F19%2Fspringbean%2F</url>
    <content type="text"><![CDATA[如下图]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Freemarker]]></title>
    <url>%2F2019%2F07%2F19%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下FreeMarker渲染模板时最基本的代码 引入FreeMarker Maven信息 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import com.google.common.base.Charsets;import com.github.pdf.tools.exception.FreeMarkerException;import freemarker.cache.FileTemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateExceptionHandler;import java.io.File;import java.io.IOException;import java.io.StringWriter;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class FreeMarkerTemplate extends AbstractTemplate &#123; private static Map&lt;String, FileTemplateLoader&gt; FILE_TEMPLATE_LOADER_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Map&lt;String, Configuration&gt; CONFIGURATION_CACHE = new ConcurrentHashMap&lt;&gt;(16); private static Configuration getConfiguration(String templatePath) &#123; if (CONFIGURATION_CACHE.get(templatePath) != null) &#123; return CONFIGURATION_CACHE.get(templatePath); &#125; Configuration config = new Configuration(Configuration.VERSION_2_3_25); config.setDefaultEncoding(Charsets.UTF_8.toString()); config.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); config.setLogTemplateExceptions(false); FileTemplateLoader fileTemplateLoader; try &#123; if (FILE_TEMPLATE_LOADER_CACHE.containsKey(templatePath)) &#123; fileTemplateLoader = FILE_TEMPLATE_LOADER_CACHE.get(templatePath); &#125; else &#123; fileTemplateLoader = new FileTemplateLoader(new File(templatePath)); &#125; &#125; catch (IOException e) &#123; throw new FreeMarkerException("fileTemplateLoader init error!", e); &#125; config.setTemplateLoader(fileTemplateLoader); CONFIGURATION_CACHE.put(templatePath, config); return config; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; Template template = getConfiguration(templatePath).getTemplate(templateName); StringWriter writer = new StringWriter(); template.process(data, writer); writer.flush(); return writer.toString(); &#125; catch (Exception ex) &#123; throw new FreeMarkerException("FreeMarkerUtil process fail", ex); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板渲染 - Velocity]]></title>
    <url>%2F2019%2F07%2F19%2Fvelocity%2F</url>
    <content type="text"><![CDATA[模板引擎除了去做后端应用的页面渲染，很多时候也可以用来生成一些代码，例如利用sql生成pojo对象，生成模板页面等这里简单记录一下Velocity渲染模板时最基本的代码 引入Velocity Maven信息 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.google.common.base.Charsets;import com.google.common.collect.Maps;import com.github.pdf.tools.exception.VelocityException;import net.sf.cglib.beans.BeanMap;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import org.apache.velocity.app.VelocityEngine;import java.io.StringWriter;import java.util.Collections;import java.util.Map;import java.util.Objects;import java.util.Properties;import java.util.concurrent.ConcurrentHashMap;/** * @author wangdongbo * @since 2019/7/3. */public class VelocityTemplate extends AbstractTemplate &#123; private static final Map&lt;String, VelocityEngine&gt; ENGINE_MAP = new ConcurrentHashMap&lt;&gt;(16); private static VelocityEngine getEngine(String templatePath) &#123; if (ENGINE_MAP.containsKey(templatePath)) &#123; return ENGINE_MAP.get(templatePath); &#125; Properties properties = new Properties(); properties.setProperty(Velocity.OUTPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.INPUT_ENCODING, Charsets.UTF_8.toString()); properties.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, templatePath); VelocityEngine velocityEngine = new VelocityEngine(properties); ENGINE_MAP.put(templatePath, velocityEngine); return velocityEngine; &#125; @Override protected String getContent(String templatePath, String templateName, Object data) &#123; try &#123; VelocityContext velocityContext = new VelocityContext(Objects.nonNull(data) ? Maps.newHashMap(BeanMap.create(data)) : Collections.emptyMap()); Template template = getEngine(templatePath).getTemplate(templateName, Charsets.UTF_8.toString()); StringWriter writer = new StringWriter(); template.merge(velocityContext, writer); writer.flush(); return writer.toString(); &#125; catch (Exception e) &#123; throw new VelocityException("Velocity exception", e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板渲染</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F07%2F19%2Flinux%2F</url>
    <content type="text"><![CDATA[1grep | zgrep]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
